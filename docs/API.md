# API Документация

## Базовый URL

Базовый URL API формируется из конфигурации сервера и версии API:

```
http://<host>:<port>/api/v<version>
```

Где:
- `<host>` — адрес сервера (по умолчанию `localhost`, настраивается в `common/config/settings.toml`)
- `<port>` — порт сервера (по умолчанию `8000`, настраивается в `common/config/settings.toml`)
- `<version>` — версия API (настраивается в `common/config/settings.toml` в секции `[api].version`)

**Пример**: При настройках по умолчанию базовый URL будет:
```
http://localhost:8000/api/v0.2
```

**Важно**: Версия API не захардкожена и должна соответствовать одной из поддерживаемых версий, указанных в `pyproject.toml` в секции `[tool.homeplanner.api].supported_versions`. Подробнее о версионировании API см. в [VERSIONING.md](VERSIONING.md).

## Принципы работы API

### Сервер — источник истины

**Важно:** Сервер является единственным источником истины для всех данных.

- Все конфликты разрешаются только на сервере
- При синхронизации через `/tasks/sync-queue` сервер проверяет время обновления (`updated_at`) каждой задачи
- Если серверная версия задачи новее, чем timestamp операции клиента → операция пропускается
- Сервер сам решает, какие операции применить, а какие пропустить
- После обработки всех операций сервер возвращает актуальное состояние всех задач
- Клиент всегда синхронизирует локальный кэш с данными, полученными с сервера

## Формат данных

### Работа с временем

**Важно**: Все даты и время хранятся и обрабатываются в **локальном времени**, без конвертации в UTC.

- Формат: ISO 8601 без указания timezone (`YYYY-MM-DDTHH:mm:ss` или `YYYY-MM-DDTHH:mm`)
- Примеры:
  - `2024-01-01T12:00:00`
  - `2024-01-01T12:00`

При отправке данных на сервер используйте локальное время. Сервер сохраняет время как есть, без преобразований. Точность сохраняемого времени — до минут (секунды и микросекунды нормализуются к `00` для абсолютных операций, таких как `/time/set`).

### Типы задач

Задачи могут быть трех типов:
- `one_time` - разовая задача
- `recurring` - задача типа "расписание" (ежедневно, еженедельно, ежемесячно, ежегодно)
- `interval` - интервальная задача (повторяется через N дней после выполнения)

### Требования к полям

#### Задачи типа "расписание" (recurring)

Для задач типа `recurring` поле `reminder_time` **обязательно**. Оно определяет:
- Для `daily` - время выполнения (часы и минуты)
- Для `weekly` - день недели и время выполнения
- Для `monthly` - число месяца и время выполнения
- Для `yearly` - дату (день и месяц) и время выполнения

Если `reminder_time` не указан для задачи типа `recurring`, сервер вернет ошибку валидации.

## Endpoints

### События (Events)

#### Создать событие
```http
POST /events/
Content-Type: application/json

{
  "title": "Название события",
  "description": "Описание",
  "event_date": "2024-01-01T12:00:00",
  "reminder_time": "2024-01-01T11:00:00"
}
```

#### Получить все события
```http
GET /events/?completed=true|false|null
```

#### Получить событие по ID
```http
GET /events/{event_id}
```

#### Обновить событие
```http
PUT /events/{event_id}
Content-Type: application/json

{
  "title": "Новое название",
  "is_completed": true
}
```

#### Удалить событие
```http
DELETE /events/{event_id}
```

#### Отметить событие как выполненное
```http
POST /events/{event_id}/complete
```

### Задачи (Tasks)

#### Создать задачу
```http
POST /tasks/
Content-Type: application/json

{
  "title": "Название задачи",
  "description": "Описание",
  "task_type": "one_time|recurring|interval",
  "recurrence_type": "daily|weekly|monthly|yearly" (обязательно для recurring, по умолчанию daily),
  "recurrence_interval": 1 (обязательно для recurring),
  "reminder_time": "2024-01-01T12:00:00" (обязательно для всех типов),
  "interval_days": 7 (обязательно для interval),
  "group_id": null,
  "assigned_user_ids": [1, 2] (необязательно, массив ID пользователей)
}
```

**Требования:**
- Для задач: `reminder_time` обязателен
- Для задач типа `interval`: `interval_days` обязателен
- Для задач типа `recurring`: `recurrence_type` (по умолчанию `daily`) и `recurrence_interval` обязательны
- Поле `assigned_user_ids` необязательно: если не указано или пустой массив, задача считается общей (доступна всем пользователям)
- При создании через Android приложение, если пользователи не указаны, автоматически назначается текущий пользователь

**Типы повторения (recurrence_type):**
- `daily` - ежедневно
- `weekdays` - по будням (пн-пт)
- `weekends` - по выходным (сб-вс)
- `weekly` - еженедельно (конкретный день недели)
- `monthly` - ежемесячно (конкретное число месяца)
- `yearly` - ежегодно (конкретная дата)

#### Получить все задачи
```http
GET /tasks/
```

Возвращает полный список задач с исходными полями (`TaskResponse`), включая поле `assigned_user_ids` (массив ID пользователей). Дополнительные параметры не требуются.

**Фильтрация по пользователю:**
- Клиент может фильтровать задачи по пользователю на своей стороне
- Задачи без назначения (`assigned_user_ids` пустой или отсутствует) считаются общими и доступны всем пользователям

#### Получить идентификаторы задач «Сегодня»
```http
GET /tasks/today/ids
Cookie: hp.selectedUserId=<user_id>
```

**Требования:**
- Эндпоинт возвращает **только массив идентификаторов** задач (не полные объекты).
- Cookie `hp.selectedUserId` с ID текущего пользователя **обязателен**.
- Возвращаются только задачи, назначенные указанному пользователю.
- Если cookie отсутствует или содержит невалидный ID пользователя, возвращается пустой массив `[]`.

**Пример ответа**
```json
[1, 42, 105]
```

**Примечание:** Для вида "Сегодня" используется именно этот эндпоинт, который возвращает только ID задач. Клиент использует эти ID для фильтрации уже загруженных полных объектов задач (полученных через `GET /tasks/`), что позволяет избежать дублирования данных и экономить трафик. Фильтрация по пользователю выполняется на сервере и является обязательной.

#### Получить задачу по ID
```http
GET /tasks/{task_id}
```

#### Обновить задачу
```http
PUT /tasks/{task_id}
Content-Type: application/json

{
  "title": "Новое название",
  "description": "Описание",
  "task_type": "one_time|recurring|interval",
  "recurrence_type": "daily|weekly|monthly|yearly" (для recurring, null для не-recurring),
  "recurrence_interval": 1 (для recurring),
  "interval_days": 7 (для interval),
  "reminder_time": "2024-01-01T12:00:00" (обязательно),
  "group_id": null,
  "assigned_user_ids": [1, 2] (необязательно, массив ID пользователей, пустой массив для общих задач),
  "active": false,
  "completed": false
}
```

**Требования:**
- Передаётся ПОЛНЫЙ объект задачи, все поля обязательны
- Для задач типа `one_time` или `interval` поле `recurrence_type` должно быть `null`
- Поле `assigned_user_ids` необязательно: если не указано или пустой массив, задача считается общей (доступна всем пользователям)

**Разрешение конфликтов:**

Сервер — источник истины. Конфликты разрешаются только на сервере по времени обновления (`updated_at`):

- При синхронизации через `/tasks/sync-queue` сервер проверяет время обновления каждой задачи
- Если серверная версия задачи новее (по `updated_at`), чем timestamp операции клиента → операция пропускается
- Сервер сам решает, какие операции применить, а какие пропустить
- После обработки всех операций сервер возвращает актуальное состояние всех задач
- Клиент получает актуальные данные и обновляет локальный кэш
- Очередь синхронизации очищается после успешной синхронизации
#### Удалить задачу
```http
DELETE /tasks/{task_id}
```

#### Отметить задачу как выполненную
```http
POST /tasks/{task_id}/complete
```

#### Отменить выполнение задачи
```http
POST /tasks/{task_id}/uncomplete
```

## WebSocket для real-time обновлений

Сервер поддерживает WebSocket соединение для получения обновлений задач в реальном времени.

### Подключение

```
ws://<host>:<port>/api/v<version>/tasks/stream
```

Где `<host>`, `<port>` и `<version>` соответствуют настройкам REST API.

**Пример**: `ws://localhost:8000/api/v0.2/tasks/stream`

### Формат сообщений

Сервер отправляет сообщения типа `task_update`:

```json
{
  "type": "task_update",
  "action": "created | updated | deleted | completed | uncompleted | shown",
  "task_id": 123,
  "task": { /* объект задачи, может отсутствовать */ }
}
```

### Формат сообщений по типам операций

#### Легкие операции (`completed`, `uncompleted`, `deleted`)

Легкие операции передают только `task_id`, поле `task` отсутствует. Клиент должен обновить локальное состояние задачи по `task_id`.

**Пример для `completed`:**
```json
{
  "type": "task_update",
  "action": "completed",
  "task_id": 123
}
```

**Пример для `deleted`:**
```json
{
  "type": "task_update",
  "action": "deleted",
  "task_id": 123
}
```

**Обработка клиентом:**
- При `completed`/`uncompleted` — обновить флаг `completed` у задачи с указанным `task_id` в локальном кэше
- При `deleted` — удалить задачу с указанным `task_id` из локального списка

#### Полные операции (`created`, `updated`, `shown`)

Полные операции передают полный объект задачи в поле `task`. Клиент должен обновить/вставить задачу используя данные из `task`.

**Пример для `created`:**
```json
{
  "type": "task_update",
  "action": "created",
  "task_id": 123,
  "task": {
    "id": 123,
    "title": "Название задачи",
    "description": "Описание",
    "task_type": "recurring",
    "reminder_time": "2024-01-01T12:00:00",
    "completed": false,
    "active": true,
    /* ... остальные поля задачи ... */
  }
}
```

**Обработка клиентом:**
- При `created`/`updated` — обновить/вставить задачу в локальный кэш и перепланировать локальные напоминания
- При `shown` — обновить задачу в локальном кэше

### Переподключение

При ошибке или закрытии соединения клиент должен выполнить переподключение с экспоненциальным бэкоффом и джиттером:
- Базовый интервал: 2-10 секунд
- Максимальный интервал: 60 секунд

Сообщения применяются в порядке получения. При сомнениях в консистентности предпочтительно перезагружать данные с бэкенда через REST API.

