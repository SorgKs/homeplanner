# API Документация

## Базовый URL

Базовый URL API формируется из конфигурации сервера и версии API:

```
http://<host>:<port>/api/v<version>
```

Где:
- `<host>` — адрес сервера (по умолчанию `localhost`, настраивается в `common/config/settings.toml`)
- `<port>` — порт сервера (по умолчанию `8000`, настраивается в `common/config/settings.toml`)
- `<version>` — версия API (настраивается в `common/config/settings.toml` в секции `[api].version`)

**Пример**: При настройках по умолчанию базовый URL будет:
```
http://localhost:8000/api/v0.2
```

**Важно**: Версия API не захардкожена и должна соответствовать одной из поддерживаемых версий, указанных в `pyproject.toml` в секции `[tool.homeplanner.api].supported_versions`. Подробнее о версионировании API см. в [VERSIONING.md](VERSIONING.md).

## Принципы работы API

### Сервер — источник истины

**Важно:** Сервер является единственным источником истины для всех данных.

- Все конфликты разрешаются только на сервере
- При синхронизации через `/tasks/sync-queue` сервер проверяет время обновления (`updated_at`) каждой задачи
- Если серверная версия задачи новее, чем timestamp операции клиента → операция пропускается
- Сервер сам решает, какие операции применить, а какие пропустить
- После обработки всех операций сервер возвращает актуальное состояние всех задач
- Клиент всегда синхронизирует локальный кэш с данными, полученными с сервера

## Формат данных

### Работа с временем

**Важно**: Все даты и время хранятся и обрабатываются в **локальном времени**, без конвертации в UTC.

- Формат: ISO 8601 без указания timezone (`YYYY-MM-DDTHH:mm:ss` или `YYYY-MM-DDTHH:mm`)
- Примеры:
  - `2024-01-01T12:00:00`
  - `2024-01-01T12:00`

При отправке данных на сервер используйте локальное время. Сервер сохраняет время как есть, без преобразований. Точность сохраняемого времени — до минут (секунды и микросекунды нормализуются к `00` для абсолютных операций, таких как `/time/set`).

### Типы задач

Задачи могут быть трех типов:
- `one_time` - разовая задача
- `recurring` - задача типа "расписание" (ежедневно, еженедельно, ежемесячно, ежегодно)
- `interval` - интервальная задача (повторяется через N дней после выполнения)

### Требования к полям

#### Задачи типа "расписание" (recurring)

Для задач типа `recurring` поле `reminder_time` **обязательно**. Оно определяет:
- Для `daily` - время выполнения (часы и минуты)
- Для `weekly` - день недели и время выполнения
- Для `monthly` - число месяца и время выполнения
- Для `yearly` - дату (день и месяц) и время выполнения

Если `reminder_time` не указан для задачи типа `recurring`, сервер вернет ошибку валидации.

## Endpoints

### События (Events)

#### Создать событие
```http
POST /events/
Content-Type: application/json

{
  "title": "Название события",
  "description": "Описание",
  "event_date": "2024-01-01T12:00:00",
  "reminder_time": "2024-01-01T11:00:00"
}
```

#### Получить все события
```http
GET /events/?completed=true|false|null
```

#### Получить событие по ID
```http
GET /events/{event_id}
```

#### Обновить событие
```http
PUT /events/{event_id}
Content-Type: application/json

{
  "title": "Новое название",
  "is_completed": true
}
```

#### Удалить событие
```http
DELETE /events/{event_id}
```

#### Отметить событие как выполненное
```http
POST /events/{event_id}/complete
```

### Задачи (Tasks)

#### Создать задачу
```http
POST /tasks/
Content-Type: application/json

{
  "title": "Название задачи",
  "description": "Описание",
  "task_type": "one_time|recurring|interval",
  "recurrence_type": "daily|weekly|monthly|yearly" (обязательно для recurring, по умолчанию daily),
  "recurrence_interval": 1 (обязательно для recurring),
  "reminder_time": "2024-01-01T12:00:00" (обязательно для всех типов),
  "interval_days": 7 (обязательно для interval),
  "group_id": null,
  "assigned_user_ids": [1, 2] (необязательно, массив ID пользователей)
}
```

**Требования:**
- Для задач: `reminder_time` обязателен
- Для задач типа `interval`: `interval_days` обязателен
- Для задач типа `recurring`: `recurrence_type` (по умолчанию `daily`) и `recurrence_interval` обязательны
- Поле `assigned_user_ids` необязательно: если не указано или пустой массив, задача считается общей (доступна всем пользователям)
- При создании через Android приложение, если пользователи не указаны, автоматически назначается текущий пользователь

**Типы повторения (recurrence_type):**
- `daily` - ежедневно
- `weekdays` - по будням (пн-пт)
- `weekends` - по выходным (сб-вс)
- `weekly` - еженедельно (конкретный день недели)
- `monthly` - ежемесячно (конкретное число месяца)
- `yearly` - ежегодно (конкретная дата)

#### Получить все задачи
```http
GET /tasks/
```

Возвращает полный список задач с исходными полями (`TaskResponse`), включая поле `assigned_user_ids` (массив ID пользователей). Дополнительные параметры не требуются.

**Фильтрация по пользователю:**
- Клиент может фильтровать задачи по пользователю на своей стороне
- Задачи без назначения (`assigned_user_ids` пустой или отсутствует) считаются общими и доступны всем пользователям

#### Получить идентификаторы задач «Сегодня»
```http
GET /tasks/today/ids
Cookie: hp.selectedUserId=<user_id>
```

**Требования:**
- Эндпоинт возвращает **только массив идентификаторов** задач (не полные объекты).
- Cookie `hp.selectedUserId` с ID текущего пользователя **обязателен**.
- Возвращаются только задачи, назначенные указанному пользователю.
- Если cookie отсутствует или содержит невалидный ID пользователя, возвращается пустой массив `[]`.

**Пример ответа**
```json
[1, 42, 105]
```

**Примечание:** Для вида "Сегодня" используется именно этот эндпоинт, который возвращает только ID задач. Клиент использует эти ID для фильтрации уже загруженных полных объектов задач (полученных через `GET /tasks/`), что позволяет избежать дублирования данных и экономить трафик. Фильтрация по пользователю выполняется на сервере и является обязательной.

#### Получить задачу по ID
```http
GET /tasks/{task_id}
```

#### Обновить задачу
```http
PUT /tasks/{task_id}
Content-Type: application/json

{
  "title": "Новое название",
  "description": "Описание",
  "task_type": "one_time|recurring|interval",
  "recurrence_type": "daily|weekly|monthly|yearly" (для recurring, null для не-recurring),
  "recurrence_interval": 1 (для recurring),
  "interval_days": 7 (для interval),
  "reminder_time": "2024-01-01T12:00:00" (обязательно),
  "group_id": null,
  "assigned_user_ids": [1, 2] (необязательно, массив ID пользователей, пустой массив для общих задач),
  "active": false,
  "completed": false
}
```

**Требования:**
- Передаётся ПОЛНЫЙ объект задачи, все поля обязательны
- Для задач типа `one_time` или `interval` поле `recurrence_type` должно быть `null`
- Поле `assigned_user_ids` необязательно: если не указано или пустой массив, задача считается общей (доступна всем пользователям)

**Разрешение конфликтов:**

Сервер — источник истины. Конфликты разрешаются только на сервере по времени обновления (`updated_at`):

- При синхронизации через `/tasks/sync-queue` сервер проверяет время обновления каждой задачи
- Если серверная версия задачи новее (по `updated_at`), чем timestamp операции клиента → операция пропускается
- Сервер сам решает, какие операции применить, а какие пропустить
- После обработки всех операций сервер возвращает актуальное состояние всех задач
- Клиент получает актуальные данные и обновляет локальный кэш
- Очередь синхронизации очищается после успешной синхронизации
#### Удалить задачу
```http
DELETE /tasks/{task_id}
```

#### Отметить задачу как выполненную
```http
POST /tasks/{task_id}/complete
```

#### Отменить выполнение задачи
```http
POST /tasks/{task_id}/uncomplete
```

## WebSocket для real-time обновлений

Сервер поддерживает WebSocket соединение для получения обновлений задач в реальном времени.

### Подключение

```
ws://<host>:<port>/api/v<version>/tasks/stream
```

Где `<host>`, `<port>` и `<version>` соответствуют настройкам REST API.

**Пример**: `ws://localhost:8000/api/v0.2/tasks/stream`

### Формат сообщений

Сервер отправляет сообщения типа `task_update`:

```json
{
  "type": "task_update",
  "action": "created | updated | deleted | completed | uncompleted | shown",
  "task_id": 123,
  "task": { /* объект задачи, может отсутствовать */ }
}
```

### Формат сообщений по типам операций

#### Легкие операции (`completed`, `uncompleted`, `deleted`)

Легкие операции передают только `task_id`, поле `task` отсутствует. Клиент должен обновить локальное состояние задачи по `task_id`.

**Пример для `completed`:**
```json
{
  "type": "task_update",
  "action": "completed",
  "task_id": 123
}
```

**Пример для `deleted`:**
```json
{
  "type": "task_update",
  "action": "deleted",
  "task_id": 123
}
```

**Обработка клиентом:**
- При `completed`/`uncompleted` — обновить флаг `completed` у задачи с указанным `task_id` в локальном кэше
- При `deleted` — удалить задачу с указанным `task_id` из локального списка

#### Полные операции (`created`, `updated`, `shown`)

Полные операции передают полный объект задачи в поле `task`. Клиент должен обновить/вставить задачу используя данные из `task`.

**Пример для `created`:**
```json
{
  "type": "task_update",
  "action": "created",
  "task_id": 123,
  "task": {
    "id": 123,
    "title": "Название задачи",
    "description": "Описание",
    "task_type": "recurring",
    "reminder_time": "2024-01-01T12:00:00",
    "completed": false,
    "active": true,
    /* ... остальные поля задачи ... */
  }
}
```

**Обработка клиентом:**
- При `created`/`updated` — обновить/вставить задачу в локальный кэш и перепланировать локальные напоминания
- При `shown` — обновить задачу в локальном кэше

### Переподключение

При ошибке или закрытии соединения клиент должен выполнить переподключение с экспоненциальным бэкоффом и джиттером:
- Базовый интервал: 2-10 секунд
- Максимальный интервал: 60 секунд

Сообщения применяются в порядке получения. При сомнениях в консистентности предпочтительно перезагружать данные с бэкенда через REST API.

### Отладочные логи (Debug Logs)

> **Важно:** Эти endpoints доступны только в дебаг-версиях приложения и предназначены для отладки.

Сервер поддерживает прием и хранение логов от Android-клиентов в бинарном формате с использованием кодов сообщений вместо текста.

#### Отправить логи на сервер

```http
POST /api/v0.2/debug-logs
Content-Type: application/json

{
  "logs": [
    {
      "timestamp": "2025-01-15T10:30:00Z",
      "level": "INFO",
      "tag": "SyncService",
      "message_code": "SYNC_START",
      "context": {
        "queueSize": 5,
        "connectionStatus": "ONLINE"
      },
      "device_id": "android_abc123",
      "device_info": "Samsung Galaxy (Android 12)",
      "app_version": "1.0.0 (1)",
      "dictionary_revision": "1.0"
    }
  ]
}
```

**Формат лога:**
- `timestamp` - время записи лога (ISO 8601)
- `level` - уровень логирования: `DEBUG`, `INFO`, `WARN`, `ERROR`
- `tag` - тег компонента (например, "SyncService", "LocalApi")
- `message_code` - код сообщения из словаря (например, "SYNC_START", "TASK_CREATE")
- `context` - JSON объект с дополнительными данными (переменные, параметры)
- `device_id` - уникальный идентификатор устройства (автоматически генерируется)
- `device_info` - информация об устройстве
- `app_version` - версия приложения
- `dictionary_revision` - ревизия словаря сообщений (например, "1.0")

**Ответ:** 201 Created с массивом созданных записей логов.

#### Получить логи

```http
GET /api/v0.2/debug-logs?device_id=android_abc123&level=ERROR&hours=24&limit=100
```

**Параметры запроса:**
- `device_id` (опционально) - фильтр по идентификатору устройства
- `level` (опционально) - фильтр по уровню: `DEBUG`, `INFO`, `WARN`, `ERROR`
- `tag` (опционально) - фильтр по тегу компонента
- `hours` (опционально, по умолчанию 24) - период времени назад в часах (1-168)
- `limit` (опционально, по умолчанию 100) - максимальное количество логов (1-1000)

**Ответ:** Массив логов, отсортированных по времени (новые первые).

**Пример ответа:**
```json
[
  {
    "id": 1,
    "timestamp": "2025-01-15T10:30:00Z",
    "level": "ERROR",
    "tag": "SyncService",
    "message_code": "SYNC_FAIL_500",
    "context": {
      "httpCode": 500,
      "retryAttempt": 1
    },
    "device_id": "android_abc123",
    "device_info": "Samsung Galaxy (Android 12)",
    "app_version": "1.0.0 (1)",
    "dictionary_revision": "1.0"
  }
]
```

#### Получить список устройств

```http
GET /api/v0.2/debug-logs/devices
```

Возвращает список всех устройств, которые отправляли логи.

**Ответ:**
```json
[
  {
    "device_id": "android_abc123",
    "last_seen": "2025-01-15T10:30:00Z",
    "device_info": "Samsung Galaxy (Android 12)",
    "app_version": "1.0.0 (1)",
    "log_count": 42
  }
]
```

#### Очистить старые логи

```http
DELETE /api/v0.2/debug-logs/cleanup?days=7
```

**Параметры запроса:**
- `days` (опционально, по умолчанию 7) - удалить логи старше указанного количества дней (1-30)

**Ответ:**
```json
{
  "deleted": 150,
  "cutoff_time": "2025-01-08T10:30:00Z"
}
```

**Примечание:** Подробнее о бинарном формате логирования и словаре сообщений см. [LOGGING_FORMAT.md](LOGGING_FORMAT.md).

