## OFFLINE CACHE — ПОВЕДЕНИЕ И СБРОС КЭША

### 1. Текущая семантика `OfflineRepository`

- **Метод `saveTasksToCache`**:
  - Добавляет/обновляет записи в таблице `tasks_cache` через `TaskCacheDao.insertTasks(...)`.
  - Не очищает таблицу полностью перед вставкой.
  - После сохранения вызывает `cleanupOldCache()` и обновление метаданных хранилища.
- **Метод `loadTasksFromCache`**:
  - Использует `TaskCacheDao.getAllTasks()` и возвращает **все** задачи из `tasks_cache`, отсортированные по `lastAccessed DESC`.
- **Политика retention в `TaskCacheDao`**:
  - `deleteOldTasks(cutoffTime)` удаляет только **старые и неактивные** задачи: `updatedAt < cutoffTime AND active = 0`.
  - Активные задачи (`active = 1`) не удаляются автоматически, чтобы "живой" оффлайн‑кэш не терялся.

Вывод: по умолчанию кэш имеет **накопительную** семантику — в нём остаются активные задачи, сохранённые ранее, даже если новый список задач не совпадает с предыдущим.

### 2. Когда нужен полный сброс кэша

Есть сценарии, где требуются **строгие снимки состояния** (snapshot semantics), а не накопительный кэш:

- Юнит‑ и инструментальные тесты вроде `OfflineRepositoryTest.saveTasksToCache_savesTasks`, где ожидание простое:
  - «Сохранили ровно этот список → получили ровно этот же список (возможно, без учёта порядка)».
- Продакшен‑сценарии типа **полного ресинка** с сервера:
  - Успешный `GET /tasks` должен приводить к тому, что оффлайн‑кэш **ровно** соответствует данным сервера.

В этих случаях старые записи в `tasks_cache` мешают:

- тесты получают "лишние" задачи из кэша;
- UI может видеть задачи, которых уже нет на сервере;
- поведение становится недетерминированным и зависит от истории использования приложения.

### 3. Рекомендации по очистке кэша

#### 3.1. В тестах (`OfflineRepositoryTest` и др.)

- В методе `setUp()` перед выполнением тестов рекомендуется явно очищать кэш и очередь:
  - вызывать `repository.clearAllCache()` и `repository.clearAllQueue()` внутри `runBlocking { ... }`.
- Это гарантирует, что каждый тест работает с **чистой** in‑memory базой и не зависит от побочных эффектов других тестов или предыдущих запусков.

#### 3.2. В сценариях snapshot‑сохранения (сервер — источник истины)

Когда мы получаем **полный список задач** с сервера (например, в `SyncService` или другом месте, которое делает "полный reload"):

- использовать стратегию «сброс + заполнение»:
  - вызвать `clearAllCache()` или эквивалентный сброс таблицы `tasks_cache`;
  - затем сохранить актуальный список через `saveTasksToCache(tasksFromServer)`.
- Альтернатива — выделить явный метод `replaceTasksCache(tasks: List<Task>)`, который внутри:
  - выполняет транзакцию: `DELETE FROM tasks_cache` + `INSERT ...`,
  - и затем обновляет метаданные хранилища.

Таким образом:

- в обычной работе приложения продолжает действовать накопительная семантика кэша (offline‑first, retention по времени и активности);
- в точках, где нужна жёсткая консистентность с сервером или тестовым набором, выполняется **полный сброс и замена** содержимого `tasks_cache`.


