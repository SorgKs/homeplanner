# Политика синхронизации и стратегия разрешения конфликтов HomePlanner vNext

Документ фиксирует договорённости по обмену данными между клиентами (web, Android) и backend, включая оффлайн-поведение и обработку конфликтов. Ответственные за актуальность: Tech Lead Backend и Tech Lead Android. Обновления вносятся по мере изменения требований, ключевые решения отражаются в `docs/CHANGELOG_HISTORY.md`.

## 1. Каналы синхронизации
- **REST API**: основной протокол получения и изменения данных задач. Все методы версиониуются (`/api/v0.2/…`) и возвращают UUID-идентификаторы, отметки времени в локальном формате проекта без указания таймзоны. Поскольку проект ещё не разворачивался в продуктивной среде, поддержка обратной совместимости с существующими клиентами не требуется.
- **WebSocket**: канал push-уведомлений о событиях (создание/обновление/удаление задач, изменения расписаний, напоминания). Формат сообщений — JSON с обязательными полями `event_type`, `entity_id`, `revision`, `payload`.
- **Брокер сообщений**: внутренний канал между сервисами (например, broker/Kafka). Клиенты взаимодействуют только опосредованно; наличие события в брокере гарантирует доставку в WebSocket-стрим.

## 2. Оффлайн-поведение клиентов
- **Локальный кэш**: хранит актуальные задачи, календари и напоминания за последние 7 дней. Формат хранения — SQLite (Android) и IndexedDB (web). Размер кэша ограничивается 20 МБ.
- **Очередь операций**: клиент сохраняет несинхронизированные изменения (CRUD) в FIFO-очереди с максимально 100 элементами. Каждая операция содержит snapshot данных и `revision`.
- **Ретраи**: экспоненциальная задержка (1с, 3с, 9с, 27с, максимум 2 минуты). После 5 неудачных попыток пользователь получает уведомление и предложение повторить вручную.
- **Порог свежести**: при отсутствии связи более 30 минут интерфейс отображает баннер «Нет синхронизации», но продолжает работать с кэшем. При восстановлении соединения запускается фоновая синхронизация.

## 3. Требования к латентности и порядку доставки
- WebSocket уведомления доставляются с p95 ≤ 3 секунд от момента фиксации изменения в backend.
- REST-запросы на чтение возвращают данные из мастера; поддерживать консистентность «read-after-write» за счёт использования `revision` в ответе.
- Клиенты подписываются на WebSocket после успешной аутентификации и подтверждают готовность сообщением `HELLO` с текущей `revision`. Backend возвращает дифф и отправляет missed events.

## 4. Стратегия разрешения конфликтов
- **Версионирование**: каждая сущность (задача, календарь) имеет поле `revision` (числовой инкремент). Клиент обязательно передаёт `revision` при обновлении. Несовпадение приводит к ответу 409 Conflict.
- **Правило «Last Write Wins»** используется только для полей, обозначенных как неблокирующие (например, заметки). Для критичных полей (время, повторяемость, исполнители) применяется стратегия «Optimistic Lock» с обязательным мерджем изменений на клиенте.
- **Обработка конфликтов**:
  - Клиент получает 409, показывает пользователю диалог с новыми данными и предлагает объединить или перезаписать.
  - При автоматическом разрешении (фоновые операции) клиент скачивает актуальную версию, объединяет допускаемые поля и повторяет запрос.
  - Все конфликты логируются на уровне клиента и backend (уровень WARNING) с указанием `entity_id` и `revision`.
- **Soft-lock**: при редактировании задач в UI вводится временная блокировка (2 минуты), сигнализирующая другим клиентам о редактировании. Soft-lock создаётся через REST и продлевается heartbeat-сообщениями.

## 5. Требования к безопасности и целостности
- WebSocket соединения защищены TLS, аутентификация — JWT. Токены обновляются через refresh-flow REST.
- Все клиентские кэши шифруются (Android — `EncryptedSharedPreferences` + SQLCipher, web — IndexedDB с `crypto.subtle`).
- Проверки целостности выполняются через цифровую подпись payload (HMAC) внутри брокера; клиенты верифицируют `revision` и `checksum`.

## 6. Мониторинг и логирование
- Backend пишет метрики p95/p99 задержек WebSocket и количество конфликтов в Prometheus (`sync_latency_seconds`, `sync_conflicts_total`).
- Android и web клиенты отправляют агрегированные метрики в аналитику раз в сутки (`offline_queue_length`, `conflicts_resolved`).
- Логи конфликтов группируются по типу сущности. Порог алерта — более 20 конфликтов в час или рост кэша до лимита.

## 7. Ответственность и контрольные точки
- **Единственный разработчик проекта** выполняет функции product owner’а, разработчика и текущего пользователя: ведёт реализацию backend, web и Android, отвечает за подготовку тестов и документации по синхронизации.
- При необходимости привлекает внешних участников (маркетинг, DevOps) точечно — для доступа к инфраструктуре или согласования аналитики. Все договорённости фиксируются в issue-трекере.
- Контроль осуществляется по чек-листам документов (`docs/DEVELOPMENT_PLAN_vNext.md`, `docs/analytics.md`), без формальных дат; переход к следующему шагу возможен только после подтверждения выполнения текущего чек-листа.

---
Дополнения и вопросы по документу фиксируются в issue-трекере (лейбл `sync-policy`).

