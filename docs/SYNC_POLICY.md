# Политика синхронизации и стратегия разрешения конфликтов HomePlanner vNext

Документ фиксирует договорённости по обмену данными между клиентами (web, Android) и backend, включая оффлайн-поведение и обработку конфликтов. Ответственные за актуальность: Tech Lead Backend и Tech Lead Android. Обновления вносятся по мере изменения требований, ключевые решения отражаются в `docs/CHANGELOG_HISTORY.md`.

## 1. Каналы синхронизации
- **REST API**: основной протокол получения и изменения данных задач. Все методы версиониуются (`/api/v0.2/…`) и возвращают UUID-идентификаторы, отметки времени в локальном формате проекта без указания таймзоны. Поскольку проект ещё не разворачивался в продуктивной среде, поддержка обратной совместимости с существующими клиентами не требуется.
- **WebSocket**: канал push-уведомлений о событиях (создание/обновление/удаление задач, изменения расписаний, напоминания). Формат сообщений — JSON с обязательными полями `event_type`, `entity_id`, `payload`.
- **Брокер сообщений**: внутренний канал между сервисами (например, broker/Kafka). Клиенты взаимодействуют только опосредованно; наличие события в брокере гарантирует доставку в WebSocket-стрим.

## 2. Оффлайн-поведение клиентов
- **Локальный кэш**: хранит актуальные задачи, календари и напоминания за последние 7 дней. Формат хранения — SQLite (Android) и IndexedDB (web). Размер кэша ограничивается 20 МБ.
- **Очередь операций**: клиент сохраняет несинхронизированные изменения (CRUD) в FIFO-очереди с максимально 100 элементами. Каждая операция содержит snapshot данных и `timestamp` (время выполнения операции на клиенте).
- **Ретраи**: экспоненциальная задержка (1с, 3с, 9с, 27с, максимум 2 минуты). После 5 неудачных попыток пользователь получает уведомление и предложение повторить вручную.
- **Порог свежести**: при отсутствии связи более 30 минут интерфейс отображает баннер «Нет синхронизации», но продолжает работать с кэшем. При восстановлении соединения запускается фоновая синхронизация.

## 3. Требования к латентности и порядку доставки
- WebSocket уведомления доставляются с p95 ≤ 3 секунд от момента фиксации изменения в backend.
- REST-запросы на чтение возвращают данные из мастера; консистентность обеспечивается через `updated_at` (время обновления).
- Клиенты подписываются на WebSocket после успешной аутентификации. Backend отправляет события об изменениях задач.

## 4. Стратегия разрешения конфликтов

**Сервер — источник истины. Конфликты обрабатываются ТОЛЬКО на сервере.**

- **Разрешение конфликтов по времени обновления**: конфликты разрешаются по времени обновления (`updated_at`), а не по ревизиям. Ревизии не используются в системе.
- **Обработка конфликтов на сервере**:
  - При синхронизации через `/tasks/sync-queue` сервер проверяет время обновления (`updated_at`) каждой задачи
  - Если серверная версия задачи новее, чем timestamp операции клиента → операция пропускается
  - Сервер сам решает, какие операции применить, а какие пропустить
  - После обработки всех операций сервер возвращает актуальное состояние всех задач
- **Обработка конфликтов на клиенте**:
  - Клиент НЕ обрабатывает конфликты самостоятельно
  - Клиент получает актуальное состояние всех задач после синхронизации
  - Клиент обновляет локальный кэш данными, полученными с сервера
  - Очередь синхронизации очищается после успешной синхронизации
- **Логирование**: все конфликты логируются на уровне сервера (уровень WARNING) с указанием `task_id`, `updated_at` и `operation timestamp`

## 5. Требования к безопасности и целостности
- WebSocket соединения защищены TLS, аутентификация — JWT. Токены обновляются через refresh-flow REST.
- Все клиентские кэши шифруются (Android — `EncryptedSharedPreferences` + SQLCipher, web — IndexedDB с `crypto.subtle`).
- Проверки целостности выполняются через цифровую подпись payload (HMAC) внутри брокера; клиенты верифицируют `updated_at` и `checksum`.

## 6. Мониторинг и логирование
- Backend пишет метрики p95/p99 задержек WebSocket и количество конфликтов в Prometheus (`sync_latency_seconds`, `sync_conflicts_total`).
- Android и web клиенты отправляют агрегированные метрики в аналитику раз в сутки (`offline_queue_length`, `conflicts_resolved`).
- Логи конфликтов группируются по типу сущности. Порог алерта — более 20 конфликтов в час или рост кэша до лимита.
- Конфликты логируются с указанием `task_id`, `updated_at` и `operation timestamp`.

## 7. Ответственность и контрольные точки
- **Единственный разработчик проекта** выполняет функции product owner’а, разработчика и текущего пользователя: ведёт реализацию backend, web и Android, отвечает за подготовку тестов и документации по синхронизации.
- При необходимости привлекает внешних участников (маркетинг, DevOps) точечно — для доступа к инфраструктуре или согласования аналитики. Все договорённости фиксируются в issue-трекере.
- Контроль осуществляется по чек-листам документов (`docs/DEVELOPMENT_PLAN_vNext.md`, `docs/analytics.md`), без формальных дат; переход к следующему шагу возможен только после подтверждения выполнения текущего чек-листа.

---
Дополнения и вопросы по документу фиксируются в issue-трекере (лейбл `sync-policy`).

