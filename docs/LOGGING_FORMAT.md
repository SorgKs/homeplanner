# Формат логирования в Android приложении HomePlanner

> **Связанные документы:** [OFFLINE_FIRST_ARCHITECTURE.md](OFFLINE_FIRST_ARCHITECTURE.md)

## Обзор

Данный документ описывает формат логирования, используемый в Android приложении HomePlanner для отслеживания состояния синхронизации, диагностики проблем и анализа производительности.

## Формат хранения логов

### Компактный бинарный формат

- **Все логи сохраняются в бинарном виде** для максимальной экономии места
- **Хранение по чанкам**: каждый чанк = 1 день, внутри чанка timestamp относительный (от 00:00:00 дня)
- **Уровень логирования (level) не хранится** - определяется по коду сообщения из словаря
- **Тег (tag) не хранится** - не требуется для расшифровки
- **Ключи контекста не хранятся** - только значения данных в фиксированном порядке
- **Типы и количество полей контекста жестко привязаны к messageCode** - определяются из словаря
- Расшифровка числовых кодов происходит на сервере по словарю сообщений

### Структура чанка (файл на день)

data class LogChunkHeader(
    val date: LocalDate,              // Дата чанка (год, месяц, день)
    val dictionaryRevision: DictionaryRevision,  // Ревизия словаря для этого чанка
    val formatVersion: String = "1.0",           // Версия формата логов
    val deviceId: String? = null                 // ID устройства (опционально)
)

data class DictionaryRevision(
    val major: Int,  // Мажорная версия
    val minor: Int   // Минорная версия
)

### Бинарный заголовок чанка (формат v1.1)

Для обеспечения однозначной совместимости между клиентом и сервером бинарный заголовок чанка фиксируется как строгий протокол байтов без выравнивания и паддинга. Все числовые поля записываются в **little-endian**.

Структура заголовка для версии формата **1.1**:

- **0–3**: `magic` — 4 байта, ASCII-строка `"HDBG"`.
- **4**: `formatVersionMajor` — 1 байт, `uint8` (значение `1` для версии `1.1`).
- **5**: `formatVersionMinor` — 1 байт, `uint8` (значение `1` для версии `1.1`).
- **6–7**: `year` — 2 байта, `uint16 LE` (например, `2025`).
- **8**: `month` — 1 байт, `uint8` (1–12).
- **9**: `day` — 1 байт, `uint8` (1–31).
- **10**: `dictionaryRevisionMajor` — 1 байт, `uint8`.
- **11**: `dictionaryRevisionMinor` — 1 байт, `uint8`.
- **12**: `deviceIdLength` — 1 байт, `uint8` (0–255), длина поля `deviceId` в байтах.
- **13…(13 + deviceIdLength − 1)**: `deviceId` — `deviceIdLength` байт, строка в кодировке UTF-8 без завершающего нуля.
- **13 + deviceIdLength … 20 + deviceIdLength − 1**: `chunkId` — 8 байт, `uint64 LE`, уникальный идентификатор чанка на устройстве.

Начиная с байта `21 + deviceIdLength` сразу следует поток бинарных записей логов в формате, описанном ниже (messageCode + timestamp + контекст).

**Важно (формат 1.1 и выше):**

- Поле `chunkId` является **обязательным** для всех чанков.
- Эндпоинт потокового бинарного логирования принимает только чанки с версией формата `1.1` и выше (см. раздел про API).

### Структура записи лога в бинарном формате

Каждая запись в чанке записывается как последовательность байт:

1. **messageCode** (2 байта):
   - Unsigned short (little-endian)
   - Диапазон: 0-65535

2. **timestamp** (3 байта):
   - Относительное время в 10-миллисекундных интервалах от начала дня (00:00:00.000)
   - Максимум 8,640,000 интервалов в дне (умещается в 3 байта: 2^24 - 1 = 16,777,215)
   - Unsigned 24-bit integer (little-endian)
   - Точность: 10 миллисекунд

3. **Данные контекста** (зависят от messageCode):
   - Количество и типы полей **жестко привязаны к коду сообщения** в словаре
   - **Ключи не хранятся** - порядок данных соответствует порядку в словаре
   - Данные записываются подряд в фиксированном порядке
   - Типы данных:
     - `Int`: 4 байта (little-endian)
     - `Long`: 8 байт (little-endian)
     - `Float`: 4 байта (IEEE 754, little-endian)
     - `Double`: 8 байт (IEEE 754, little-endian)
     - `Boolean`: 1 байт (0 = false, 1 = true)
     - `String`: 1 байт (длина, 0-255) + UTF-8 байты

### Пример размера записи

Для сообщения с кодом 32 (QUEUE_SIZE) и одним полем типа Float (например, "percentage"):

```
[messageCode: 2 байта] [timestamp: 3 байта] [Float: 4 байта]
```

**Итого: 9 байт на запись** (вместо 300+ байт при хранении как Java/Kotlin объекты)

Для 1000 записей в день: ~9 КБ вместо ~300 КБ - **экономия ~97%** места.

**Важно:** 
- В заголовке каждого чанка указывается ревизия словаря сообщений
- Все записи в чанке используют одну и ту же ревизию словаря
- При чтении логов используется ревизия из заголовка чанка для правильной расшифровки кодов и восстановления структуры контекста

**Важно:** В каждом файле лога должна указываться ревизия словаря сообщений в заголовке файла. Все записи в файле используют одну и ту же ревизию словаря.

## Словарь сообщений приложения

### Концепция

- **Цель:** Экономия места в бинарных логах за счёт использования кодов вместо текстовых описаний
- Создаётся словарь сообщений, где каждому событию присвоено:
  - **Числовой код** (`numeric_code: uint16`, диапазон 0–65535) — единственный код, который реально записывается в бинарный поток.
  - **Текстовый шаблон сообщения** (полное описание события с плейсхолдерами для значений переменных).
- В приложении для логирования используется **только числовой код** (`numeric_code`)
- Текстовое описание и шаблон **не загружаются в приложение** (хранятся только на сервере или в документации, а также могут быть продублированы в комментариях к коду для удобства разработчиков)
- При расшифровке логов на сервере числовые коды сопоставляются со словарём и превращаются в текстовые сообщения

### Структура словаря

Словарь сообщений хранится **на сервере** (и/или в сопровождающей документации) и содержит для каждой ревизии (`DictionaryRevision`) набор записей вида:

- `numeric_code: uint16` — числовой код сообщения, который пишет клиент.
- `template: String` — текстовый шаблон сообщения, например:  
  - `"Синхронизация начата"`  
  - `"Ошибка: ожидалось %f%, фактически %f%"`  
  Здесь плейсхолдер `%f%` обозначает значение типа `Float`. При необходимости могут быть введены другие типы плейсхолдеров (`%d%` для целых чисел, `%s%` для строк и т.п.).
- `level: LogLevel` — уровень логирования (INFO, ERROR и т.д.).
- `context_schema: List<Field>` — строгий упорядоченный список полей контекста, каждое поле описывается:
  - `name: String` — логическое имя поля (для удобства на сервере);
  - `type: String` — тип (`"int" | "long" | "float" | "double" | "bool" | "string"`).
- `revision_major: Int`, `revision_minor: Int` — ревизия словаря, к которой относится запись.

**Правило соответствия плейсхолдеров и контекста:**

- Количество и типы плейсхолдеров в `template` (например, два `%f%`) **строго соответствуют** количеству и типам полей в `context_schema`.
- Порядок полей в `context_schema` = порядок следования значений в бинарном потоке.

Пример записи словаря для сообщения:

- Шаблон: `"Ошибка: ожидалось %f%, фактически %f%"`
- `context_schema`:
  - `[{ "name": "awaited", "type": "float" }, { "name": "fact", "type": "float" }]`

Клиент при логировании может использовать упрощённый вызов (логическая запись):

```kotlin
logSave(32, awaited, fact)  // Ошибка: ожидалось %fawaited%, фактически %fact%
```

Где:

- `32` — `numeric_code: uint16` из словаря (пишется в бинарное поле `messageCode`).
- `awaited`, `fact` — значения двух полей контекста типа `Float`, которые последовательно кодируются в бинарный поток.

На стороне клиента в коде нет текстового шаблона; он может быть указан только в комментарии для справки:

```kotlin
private const val MSG_EXPECTED_ACTUAL_MISMATCH: UShort = 32u  // Ошибка: ожидалось %f%, фактически %f%
```

На сервере по `(dictionaryRevision, numeric_code)` находится запись словаря, читается `template` и `context_schema`, после чего значения контекста подставляются в шаблон.

### Использование в логировании

#### Передача данных переменных



**Важно:**
- Параметр `context` принимает `Map<String, Any>` и может содержать любые типы данных (String, Number, Boolean и т.д.)
- Данные из `context` автоматически конвертируются в JSON при отправке на сервер
- Контекст хранится в поле `context` таблицы `debug_logs` на сервере
- Код сообщения (`messageCode`) остается статическим идентификатором, а динамические данные передаются в `context`

#### Разделение логов по устройствам

Каждый лог автоматически содержит уникальный идентификатор устройства (`device_id`), который генерируется при первом запуске и сохраняется в SharedPreferences. Это позволяет серверу разделять логи от разных устройств:

```kotlin
// Device ID генерируется автоматически в LogSender
// Используется ANDROID_ID или UUID, сохраненный в SharedPreferences
// ID остается постоянным для каждого устройства между запусками
```

На сервере можно фильтровать логи по `device_id`:
```
GET /api/v0.2/debug-logs?device_id=android_abc123...
```

### Преимущества

- Значительная экономия места в бинарных логах
- Быстрая запись и чтение (коды короче текстов)
- Единообразие логирования (стандартизированные коды)
- Расшифровка на сервере при анализе

### Версионирование словаря

**Структура ревизии:**

- Ревизия словаря состоит из **мажорной** и **минорной** версий (например, 1.0, 1.1, 2.0)
- Формат: `major.minor` (например, `1.0`, `1.2`, `2.0`)

**Правила изменения словаря:**

1. **В рамках одной мажорной версии:**
   - **Не допускается изменение существующих кодов** (код не может быть изменён или удалён)
   - **Разрешено только добавление новых кодов** (минорная версия увеличивается)
   - Пример: версия 1.0 → 1.1 (добавлены новые коды)

2. **При изменении мажорной версии:**
   - Разрешено изменение или удаление существующих кодов
   - Разрешено добавление новых кодов
   - Пример: версия 1.5 → 2.0 (изменены или удалены существующие коды)

**Указание ревизии в логах:**

- **В каждом файле лога должна указываться ревизия словаря**, используемая при записи логов
- Ревизия указывается в заголовке файла лога или в метаданных
- При чтении логов используется ревизия из файла для правильной расшифровки кодов

**Структура файла лога:**

```kotlin
data class LogFileHeader(
    val dictionaryRevision: DictionaryRevision,  // Ревизия словаря для этого файла
    val formatVersion: String,                    // Версия формата логов
    val createdAt: Long,                          // Время создания файла
    val deviceId: String?                         // ID устройства (опционально)
)

data class LogFile(
    val header: LogFileHeader,
    val entries: List<LogEntry>
)
```

**Хранение словаря:**

- Словарь хранится на сервере или в документации
- Каждая версия словаря хранится отдельно для совместимости
- При обновлении словаря старые логи остаются читаемыми по соответствующей версии словаря
- При чтении логов используется ревизия из файла для выбора правильной версии словаря

## Инциденты с ошибками

### Определение инцидентов

- **Важно:** Отдельно сохраняются инциденты с ошибками (кроме ошибок соединения)
- Инциденты включают:
  - Серверные ошибки (HTTP 500, 503, 429)
  - Ошибки валидации (HTTP 400)
  - Ошибки авторизации (HTTP 401, 403)
  - Конфликты (HTTP 409)
  - Критические системные ошибки
- Ошибки соединения (сетевые ошибки) **не сохраняются** как инциденты

### Структура инцидента

```kotlin
data class ErrorIncident(
    val id: String,                    // Уникальный идентификатор инцидента
    val timestamp: Long,                // Время возникновения ошибки
    val errorType: SyncErrorType,       // Тип ошибки
    val httpCode: Int?,                 // HTTP-код (если применимо)
    val messageCode: String,             // Код сообщения из словаря
    val context: Map<String, Any>,       // Дополнительный контекст
    val taskId: Int?,                   // ID задачи (если применимо)
    val retryAttempt: Int,              // Количество попыток retry
    val sentToServer: Boolean = false   // Флаг отправки на сервер
)

enum class SyncErrorType {
    NETWORK_ERROR,      // Сетевые ошибки (не сохраняются как инциденты)
    CONFLICT,  // Конфликты (HTTP 409)
    SERVER_ERROR,       // Серверные ошибки (500, 503, 429)
    VALIDATION_ERROR,   // Ошибки валидации (400)
    AUTH_ERROR,         // Ошибки авторизации (401, 403)
    UNKNOWN_ERROR       // Неизвестные ошибки
}
```



> Историческая заметка: ранний JSON‑отправщик логов (формат v1, `POST /api/v0.2/debug-logs`) и связанный с ним компонент `LogSender` в Android‑клиенте удалены; текущий протокол использует только поток бинарных чанков (`/debug-logs/chunks`).

#### Получение логов (v2)

Эндпоинт чтения логов использует путь:

```http
GET /api/v0.2/debug-logs?device_id={device_id}&level={level}&from={from}&to={to}&limit={limit}&query={query}
```

Параметры:

- `device_id` — **обязательный** параметр, идентификатор устройства.
- `level` — опциональный фильтр по уровню (`DEBUG`, `INFO`, `WARN`, `ERROR`).
- `from` / `to` — опциональные границы по времени (ISO 8601).
- `limit` — максимальное количество логов (по умолчанию 100, максимум 1000).
- `query` — опциональный текстовый поиск по полю `text` (substring/ILIKE).

Ответ:

```json
{
  "logs": [
    {
      "timestamp": "2025-01-15T10:30:00Z",
      "level": "INFO",
      "text": "Синхронизация начата, очередь: 5 задач"
    }
  ]
}
```

На сервере для v2‑формата логи хранятся в минималистичном виде:

- `device_id`
- `timestamp`
- `level`
- `text`

#### Список устройств (v2)

```http
GET /api/v0.2/debug-logs/devices
```

Возвращает список всех устройств, которые отправляли логи:

- `device_id` - идентификатор устройства
- `last_seen` - время последнего лога
- `log_count` - количество логов от устройства

#### Очистка старых логов
```http
DELETE /api/v0.2/debug-logs/cleanup?days=7
```

Удаляет логи старше указанного количества дней (по умолчанию 7, максимум 30).

## Политика удаления логов

### Обычные логи

- Удаляются через **7 дней** после создания
- Автоматическая очистка при старте приложения или периодически
- Очистка не затрагивает инциденты

### Аварийные логи (инциденты)

- Удаляются через **20 дней** после создания
- Удаляются только после успешной отправки на сервер
- Если отправка не удалась, инцидент сохраняется до успешной отправки или истечения 20 дней

### Реализация очистки

```kotlin
suspend fun cleanupOldLogs() {
    val now = System.currentTimeMillis()
    val sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000L)
    val twentyDaysAgo = now - (20 * 24 * 60 * 60 * 1000L)
    
    // Удаление обычных логов старше 7 дней
    logRepository.deleteLogsOlderThan(sevenDaysAgo)
    
    // Удаление отправленных инцидентов старше 20 дней
    incidentRepository.deleteSentIncidentsOlderThan(twentyDaysAgo)
    
    Log.i(TAG, LogMessageCode.LOGS_CLEANUP.code, mapOf(
        "timestamp" to now
    ))
}
```

## Примеры использования

### Создание файла лога с ревизией словаря

```kotlin
// Создание файла лога с указанием ревизии словаря
val currentDictionaryRevision = DictionaryRevision(major = 1, minor = 0)

val logFileHeader = LogFileHeader(
    dictionaryRevision = currentDictionaryRevision,
    formatVersion = "1.0",
    createdAt = System.currentTimeMillis(),
    deviceId = getDeviceId()
)

val logFile = LogFile(
    header = logFileHeader,
    entries = mutableListOf()
)

// При записи логов в файл используется ревизия из заголовка
logFile.entries.add(LogEntry(
    timestamp = System.currentTimeMillis(),
    level = LogLevel.INFO,
    tag = "SyncService",
    messageCode = LogMessageCode.SYNC_START.code,
    context = mapOf("queueSize" to 5)
))
```

### Логирование операции синхронизации

```kotlin
val logger = BinaryLogger.getInstance()

// Начало синхронизации
logger?.log(
    level = LogLevel.INFO,
    tag = "SyncService",
    messageCode = LogMessageCode.SYNC_START,
    context = mapOf(
        "queueSize" to queueItems.size,
        "connectionStatus" to connectionStatus.name,
        "timestamp" to System.currentTimeMillis()
    )
)

// Успешная синхронизация
logger?.log(
    level = LogLevel.INFO,
    tag = "SyncService",
    messageCode = LogMessageCode.SYNC_SUCCESS,
    context = mapOf(
        "syncedCount" to syncedCount,
        "duration" to duration,
        "timestamp" to System.currentTimeMillis()
    )
)

// Ошибка синхронизации
logger?.log(
    level = LogLevel.ERROR,
    tag = "SyncService",
    messageCode = LogMessageCode.SYNC_FAIL_500,
    context = mapOf(
        "errorType" to SyncErrorType.SERVER_ERROR.name,
        "httpCode" to 500,
        "retryAttempt" to attempt,
        "timestamp" to System.currentTimeMillis()
    )
)
```

### Логирование создания задачи

```kotlin
val logger = BinaryLogger.getInstance()

logger?.log(
    level = LogLevel.INFO,
    tag = "LocalApi",
    messageCode = LogMessageCode.TASK_CREATE,
    context = mapOf(
        "taskId" to task.id,
        "title" to task.title,
        "timestamp" to System.currentTimeMillis()
    )
)
```

### Примеры передачи различных типов данных

```kotlin
val logger = BinaryLogger.getInstance()

// Числовые значения
logger?.log(
    level = LogLevel.INFO,
    tag = "Test",
    messageCode = LogMessageCode.QUEUE_SIZE,
    context = mapOf(
        "count" to 42,           // Int
        "percentage" to 85.5,     // Double
        "totalBytes" to 1024L     // Long
    )
)

// Строковые значения
logger?.log(
    level = LogLevel.INFO,
    tag = "Test",
    messageCode = LogMessageCode.SYNC_START,
    context = mapOf(
        "status" to "ONLINE",
        "url" to "https://example.com/api"
    )
)

// Булевы значения
logger?.log(
    level = LogLevel.DEBUG,
    tag = "Test",
    messageCode = LogMessageCode.SYNC_START,
    context = mapOf(
        "isRetry" to true,
        "hasConnection" to false
    )
)

// Смешанные типы данных
logger?.log(
    level = LogLevel.ERROR,
    tag = "SyncService",
    messageCode = LogMessageCode.SYNC_FAIL_500,
    context = mapOf(
        "httpCode" to 500,                    // Int
        "errorMessage" to "Internal error",   // String
        "retryCount" to 3,                    // Int
        "shouldRetry" to true,                // Boolean
        "requestDuration" to 1250L            // Long (milliseconds)
    )
)
```

### Логирование инцидента

```kotlin
val incident = ErrorIncident(
    id = UUID.randomUUID().toString(),
    timestamp = System.currentTimeMillis(),
    errorType = SyncErrorType.SERVER_ERROR,
    httpCode = 500,
    messageCode = LogMessageCode.SYNC_FAIL_500.code,
    context = mapOf(
        "queueSize" to queueItems.size,
        "retryAttempt" to attempt
    ),
    taskId = taskId,
    retryAttempt = attempt,
    sentToServer = false
)

incidentRepository.saveIncident(incident)
```

## Версионирование

### Версия формата логов

- Формат логов версионируется для обеспечения совместимости
- При изменении формата увеличивается версия
- Старые логи остаются читаемыми по старой версии формата

### Версия словаря сообщений

- Словарь сообщений версионируется отдельно с использованием мажорной и минорной версий
- **Мажорная версия:** Увеличивается при изменении или удалении существующих кодов
- **Минорная версия:** Увеличивается при добавлении новых кодов (в рамках одной мажорной версии)
- В каждом файле лога указывается ревизия словаря, используемая при записи
- Старые логи расшифровываются по версии словаря, указанной в файле лога
- Все версии словаря хранятся на сервере для обеспечения совместимости

## Резюме реализации

### Текущая реализация

1. **BinaryLogger** - утилита для записи логов в бинарном формате:
   - Метод `log()` принимает код сообщения и контекст (Map<String, Any>)
   - Логи буферизуются и автоматически отправляются на сервер
   - Работает только в дебаг-версиях

2. **LogSender** - отправка логов на сервер:
   - Принимает логи от BinaryLogger
   - Отправляет батчами на сервер через HTTP
   - Автоматически добавляет `device_id`, `device_info`, `app_version`

3. **DeviceIdHelper** - получение уникального идентификатора устройства:
   - Использует ANDROID_ID или генерирует UUID
   - Сохраняет UUID в SharedPreferences для постоянства

4. **Серверная часть**:
   - Модель `DebugLog` хранит логи с кодами сообщений и контекстом
   - API endpoints для получения и фильтрации логов
   - Словарь сообщений для расшифровки кодов на сервере

### Передача данных переменных

Данные переменных передаются через параметр `context: Map<String, Any>`:

```kotlin
BinaryLogger.getInstance()?.log(
    level = LogLevel.INFO,
    tag = "Component",
    messageCode = LogMessageCode.EVENT_CODE,
    context = mapOf(
        "variable1" to value1,
        "variable2" to value2,
        // Любые данные переменных
    )
)
```

Контекст автоматически конвертируется в JSON и хранится в базе данных.

---

## Бинарные чанки логов (потоковый формат v2)

Данный раздел описывает **расширенный потоковый формат v2**, в котором:

- логи в приложении пишутся **единым бинарным потоком** в компактном формате;
- этот же бинарный поток **отправляется на сервер без раскодирования в JSON**;
- сервер **расшифровывает чанки** и сохраняет логи в читаемом виде.

### 1. Бинарный поток и метаданные чанка

- Все логи устройства записываются в **последовательность чанков**, где **каждый чанк = один бинарный файл**.
- Внутри файла:
  - в начале — **заголовок чанка (метаданные)**;
  - далее — **непрерывный поток бинарных записей**, каждая в компактном формате из раздела «Компактный бинарный формат».
- Заголовок содержит:
  - **магик** (`HDBG`);
  - **версию формата** (например, `1.0`);
  - **дату чанка** (год, месяц, день);
  - **идентификатор устройства** (`device_id`);
  - **ревизию словаря сообщений** (`dictionary_revision`), необходимую для корректного декодирования бинарных записей.
- Все записи в чанке используют одну и ту же дату (от неё считается относительный `timestamp`) и одну и ту же ревизию словаря.

**Ограничение размера чанка:**

- Максимальный размер одного бинарного файла‑чанка составляет **1 КБ** (1024 байта).
- Если после записи превышен лимит:
  - текущий чанк **закрывается**;
  - начинается **новый чанк** с теми же метаданными (той же датой), если не наступили новые сутки.

### 2. Таймер и отправка чанков

- На устройстве работает **периодическая отправка чанков**:
  - базовый интервал отправки — **каждые 15 секунд**;
  - отправка выполняется **только если есть хотя бы один завершённый чанк**.
- Алгоритм отправки:
  1. Текущий активный чанк записывается в файл как бинарный поток (заголовок + записи).
  2. Когда приходит время отправки:
     - если **предыдущий чанк уже подтверждён сервером** и с момента этого подтверждения прошло **15+ секунд**, текущий чанк:
       - **завершается** (файл закрывается);
       - помечается как готовый к отправке;
       - **открывается новый чанк** для последующих записей;
     - если **предыдущий чанк ещё не подтверждён**, текущий чанк **не прерывается** (запись продолжается в тот же файл), даже если с начала его записи прошло больше 15 секунд.
  3. Завершённые чанки отправляются на сервер:
     - по одному или батчем;
     - с `Content-Type: application/octet-stream`.
  4. После **успешного подтверждения** со стороны сервера:
     - соответствующий файл чанка **удаляется** с устройства.

### 3. Смена суток и метаданных

- При наступлении **новых календарных суток** для часового пояса устройства:
  - текущий чанк **завершается**;
  - **всегда создаётся новый чанк** с новой датой в заголовке;
  - при необходимости может быть изменена ревизия словаря (если она была обновлена).
- Правило с неотправленным предыдущим чанком сохраняется:
  - если старый чанк ещё не подтверждён сервером, он остаётся в очереди на отправку;
  - новый чанк создаётся **независимо от статуса отправки** старого, так как метаинформация (дата) изменилась.

### 4. Обработка чанков на сервере

- Для **каждого устройства** на сервере хранится **отдельный лог**:
  - `device_id` используется только для маршрутизации/выбора файла/таблицы логов;
  - внутри самого лога/записей **данные об устройстве не дублируются**.

- Серверный API принимает бинарные чанки, например:

```http
POST /api/v0.2/debug-logs/chunks
Content-Type: application/octet-stream
X-Chunk-Id: 123456789        # дублирование chunk_id из заголовка чанка (uint64 в десятичном виде)
X-Device-Id: android_abc123  # дублирование device_id из заголовка чанка (опционально)

<binary data>
```

Ответ сервера всегда имеет HTTP‑статус `200 OK` и JSON‑формат:

```json
{ "result": "ACK", "chunk_id": "123456789" }
```

или

```json
{ "result": "REPIT", "chunk_id": "123456789" }
```

При окончательно неисправимом чанке (повторная ошибка разбора на сервере) сервер возвращает:

```json
{
  "result": "ACK",
  "chunk_id": "123456789",
  "error": "UNRECOVERABLE_CHUNK"
}
```

#### Общий алгоритм обработки

- Обработка на сервере:
  1. Чтение заголовка:
     - проверка магика и версии формата;
     - извлечение даты, `device_id` и `dictionary_revision` (используется только на этапе декодирования).
  2. Последовательное чтение записей до конца потока:
     - для каждой записи читается:
       - **messageCode** (2 байта, `unsigned short`, little-endian) — **числовой код** (`numeric_code`);
       - **timestamp** (3 байта, `unsigned 24-bit`, little-endian) — число 10‑мс интервалов от начала дня;
       - **данные контекста** — значения в порядке и типах, определённых в словаре для данного `messageCode` и указанной ревизии словаря.
  3. По `dictionary_revision` и числовому `messageCode`:
     - находят **шаблон текстового сообщения** и схему контекста (типы и порядок полей);
     - подставляют значения из контекста в шаблон (например, в места `%f%`), получая **готовую текстовую строку лога**.
  4. На сервере лог хранится в **минималистичном виде**:
     - `timestamp` — восстановленное абсолютное время (дата чанка + относительное время);
     - `level` — уровень логирования (восстанавливается из словаря/кода сообщения);
     - `text` — финальная текстовая строка сообщения.
  5. Внутри серверного лога **не хранятся**:
     - `device_id` (он задаётся на уровне выбранного лога для устройства);
     - `app_version` — вместо этого при смене версии приложения клиент генерирует отдельное лог‑сообщение вроде `"App version changed to 1.2.3 (45)"`;
     - `dictionary_revision` — используется только на этапе декодирования бинарного чанка;
     - `message_code`, `context` и другие технические поля бинарного формата — после генерации текстовой строки не сохраняются.

#### Обработка ошибок при расшифровке чанков и протокол ACK/REPIT

Для предотвращения бесконечного ретрая и порчи данных для других устройств вводятся чёткие правила обработки ошибок и протокол подтверждения чанков.

- **Класс ошибок:** любая ошибка при разборе чанка, включая:
  - неверный магик или неподдерживаемая версия формата;
  - некорректный или отсутствующий `dictionary_revision`;
  - отсутствие записи словаря для пары (`dictionary_revision`, `messageCode`);
  - нехватка байт для чтения контекста по `context_schema`;
  - любые другие ошибки при чтении бинарных данных.

- **Первая ошибка по чанку:**
  - сервер записывает подробное сообщение в техлог, привязанный к соответствующему клиенту (по `device_id`, если он успешно прочитан);
  - **немедленно прекращает расшифровку текущего чанка** (частичный успешный разбор не выполняется);
  - считает чанк **необработанным** и возвращает клиенту ответ с `result = "REPIT"` и тем же `chunk_id`.

- **Повторная ошибка по тому же чанку:**
  - при повторной попытке обработки того же чанка (идентифицируемого по комбинации `device_id` + `chunk_id`) сервер снова логирует ошибку;
  - чанк считается **окончательно неисправимым**;
  - сервер возвращает клиенту ответ с `result = "ACK"` и `error = "UNRECOVERABLE_CHUNK"`, чтобы клиент мог удалить файл и не отправлять его снова;
  - бинарные данные чанка **не сохраняются и не расшифровываются**, никакая часть записей из этого чанка не попадает в пользовательское хранилище логов.

- **Сырой бинарный чанк на сервере не хранится** ни при первой, ни при повторной ошибке — остаётся только серверный техлог с описанием проблемы.

Таким образом:

- **На устройстве** логи существуют только в компактном бинарном виде (чанки);
- **В трафике** на сервер также передаётся компактный бинарный поток;
- **На сервере** логи расшифровываются и хранятся в удобном для анализа читаемом виде в виде тройки: время, уровень, текст сообщения, без избыточных служебных полей.

**Последнее обновление:** 2025-01-15  
**Версия формата:** 1.1  
**Ревизия словаря сообщений:** 1.0
