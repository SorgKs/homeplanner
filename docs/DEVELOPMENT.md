# Документация для разработчиков

Внутренняя документация проекта HomePlanner для разработчиков.

## Структура проекта

```
HomePlanner/
├── backend/          # Backend API (FastAPI)
│   ├── models/      # SQLAlchemy модели
│   ├── schemas/     # Pydantic схемы
│   ├── routers/     # API роутеры
│   ├── services/    # Бизнес-логика
│   ├── config.py    # Конфигурация
│   ├── database.py  # Настройка БД
│   └── main.py      # Точка входа
├── frontend/         # Веб-интерфейс
│   ├── app.js       # Основная логика
│   ├── api.js       # API клиент
│   ├── index.html   # HTML
│   └── style.css    # Стили
├── android/          # Android приложение
├── tests/            # Тесты
├── docs/             # Документация
├── alembic/          # Миграции БД
└── config/           # Конфигурационные файлы
```

## Технологический стек

### Backend
- **Python 3.11+** - основной язык
- **FastAPI** - веб-фреймворк
- **SQLAlchemy** - ORM
- **SQLite/PostgreSQL** - база данных
- **Alembic** - миграции базы данных
- **Pydantic** - валидация данных
- **uvicorn** - ASGI сервер

### Frontend
- **HTML/CSS/JavaScript** - веб-интерфейс
- API интеграция с backend

### Android
- **Kotlin/Java** - разработка приложения
- **Android SDK** - платформа

### Инструменты разработки
- **uv** - менеджер пакетов Python
- **pytest** - тестирование
- **Ruff** - линтер и форматтер
- **mypy** - проверка типов

## Установка для разработки

### 1. Клонирование репозитория

```bash
git clone <repository-url>
cd HomePlanner
```

### 2. Установка uv (если еще не установлен)

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

### 3. Установка зависимостей

```bash
# Установка всех зависимостей (включая dev)
uv sync --all-extras

# Или с pip
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -e ".[dev]"
```

### 4. Настройка окружения разработки

Создайте `.env` файл с настройками для разработки (см. пример в README).

## Разработка

### Запуск сервера разработки

```bash
# С автоперезагрузкой (uv)
uv run python -m backend.main

# Или с uvicorn напрямую
uv run uvicorn backend.main:app --reload --host 0.0.0.0 --port 8000
```

### Запуск frontend

Frontend - статические файлы, можно открыть напрямую в браузере или запустить простой HTTP сервер:

```bash
cd frontend
python -m http.server 8080
```

#### Реальное время и события задач

- WebSocket сервера: `ws://<host>:8000/ws`; статус подключений: `GET /ws/status`.
- `backend/routers/tasks.py` рассылает `task_update` при создании/редактировании/подтверждении/отмене/удалении. Из синхронных обработчиков отправка выполняется через `anyio.from_thread.run(...)`.
- `frontend/app.js` автоматически подключается, парсит входящие сообщения и обновляет `allTasks` локально без полной перезагрузки данных.
- Автоматические вызовы `mark-shown` при рендере «Сегодня» отключены, чтобы избежать перегрузки и `ERR_INSUFFICIENT_RESOURCES`.

### Стиль кода

Проект использует **Ruff** для линтинга и форматирования:

```bash
# Проверка кода
uv run ruff check .

# Автоисправление
uv run ruff check --fix .

# Форматирование
uv run ruff format .
```

### Проверка типов

Проект использует **mypy** для проверки типов:

```bash
uv run mypy backend/
```

## Тестирование

Проект использует **pytest** для тестирования.

### Запуск тестов

```bash
# Все тесты
uv run pytest

# С подробным выводом
uv run pytest -v

# Конкретный тест
uv run pytest tests/test_tasks.py

# С покрытием
uv run pytest --cov=backend --cov-report=html

# Открыть отчет о покрытии
open htmlcov/index.html  # Mac
xdg-open htmlcov/index.html  # Linux
```

### Структура тестов

Все тесты находятся в папке `tests/`:
- `test_*.py` - файлы с тестами
- Используется pytest с async поддержкой
- Все тесты должны быть типизированы

### Пример теста

```python
import pytest
from httpx import AsyncClient
from backend.main import app


@pytest.mark.asyncio
async def test_create_task():
    """Test task creation."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/api/v1/tasks/",
            json={
                "title": "Test task",
                "recurrence_type": "daily",
            }
        )
        assert response.status_code == 200
```

## База данных

### Миграции

Проект использует **Alembic** для миграций:

```bash
# Создание новой миграции
uv run alembic revision --autogenerate -m "Описание изменений"

# Применение миграций
uv run alembic upgrade head

# Откат миграции
uv run alembic downgrade -1
```

### Работа с БД в разработке

Для работы с базой данных используется SQLAlchemy. Модели находятся в `backend/models/`.

### Работа с временем

**Важно**: Проект использует только **локальное время**, без конвертации в UTC.

- Все даты и время хранятся в базе данных как локальное время (без timezone)
- При получении и сохранении данных используется локальное время без преобразований
- Формат дат: ISO 8601 без указания timezone (`YYYY-MM-DDTHH:mm:ss`)

Это означает:
- Нет конвертации между UTC и локальным временем
- Время сохраняется как есть, без преобразований
- При форматировании для отображения время используется напрямую из базы данных

#### Замечание об «отметке показа» (mark-shown)

- Эндпоинт `POST /api/v1/tasks/{id}/mark-shown` доступен, но не должен вызываться массово во время рендера списков.
- Веб‑клиент больше не инициирует автоматические вызовы при каждом показе списка — используйте явную, дозированную логику, если метрика «показано» необходима бизнес‑процессом.

### Требования к задачам типа "расписание"

Для задач типа `recurring` (расписание) поле `reminder_time` является **обязательным**:
- Валидация выполняется на уровне Pydantic схем (`TaskBase`, `TaskUpdate`)
- Валидация также проверяется в сервисах (`create_task`, `update_task`)
- `reminder_time` определяет:
  - Для `daily` - время выполнения (часы и минуты)
  - Для `weekly` - день недели и время выполнения
  - Для `monthly` - число месяца и время выполнения
  - Для `yearly` - дату (день и месяц) и время выполнения

## Принципы разработки

Проект следует следующим принципам:

1. **Модульная архитектура** - четкое разделение на модели, схемы, роутеры, сервисы
2. **Типизация** - весь код должен быть типизирован
3. **Документирование** - код должен содержать docstrings (PEP 257)
4. **Тестирование** - комплексное покрытие тестами
5. **Управление зависимостями** - через `uv` или `pyproject.toml`
6. **Линтинг** - использование Ruff для поддержания качества кода

### Стиль кода

- Типизация обязательна для всех функций и классов
- Docstrings должны быть в формате PEP 257
- Длина строк: 100 символов (конфигурация в `pyproject.toml`)
- Использование async/await для асинхронных операций
- Обработка ошибок с явным указанием типов исключений

## API Документация

См. [API.md](./API.md) для подробной документации по API endpoints.

## Контрибьюция

1. Создайте ветку для новой функции
2. Внесите изменения с тестами
3. Убедитесь, что все тесты проходят
4. Убедитесь, что код проходит линтер (Ruff)
5. Создайте Pull Request

## Отладка

### Логирование

Проект использует стандартный Python logging. Настройте уровень логирования в коде или через переменные окружения.

### Отладка с помощью IDE

Для отладки настройте конфигурацию запуска:
- **Модуль**: `backend.main`
- **Параметры**: как при обычном запуске
- **Рабочая директория**: корень проекта
- **Переменные окружения**: из `.env` файла

## Полезные команды

```bash
# Установка новых зависимостей
uv add package-name

# Установка dev зависимостей
uv add --dev package-name

# Обновление зависимостей
uv sync --upgrade

# Проверка безопасности зависимостей
# (используйте pip-audit или аналогичные инструменты)
```

## Структура API

API организован по REST принципам:

- `/api/v1/events` - управление событиями
- `/api/v1/tasks` - управление задачами
- `/api/v1/groups` - управление группами

Подробнее см. [API.md](./API.md).

