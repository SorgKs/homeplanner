## Предложения по доработке плана офлайн‑режима

### 1. Декомпозиция текущего плана на отдельные артефакты

**Проблема**  
Текущий документ `PLAN_OFFLINE_MODE.md` объединяет в себе бизнес‑требования, технический дизайн, спецификацию алгоритма синхронизации и детальный тест‑план. Это затрудняет чтение, ревью и сопровождение документа.

**Предлагаемое улучшение**  
Разделить содержимое текущего документа на несколько целевых артефактов:

1. `OFFLINE_REQUIREMENTS.md`
   - Описание продуктовых/функциональных требований к оффлайн‑режиму.
   - Канонические правила отображения задач («Сегодня», «Все задачи»).
   - Ожидаемое поведение при переходах офлайн/онлайн (без деталей реализации).

2. `OFFLINE_CLIENT_DESIGN.md`
   - Архитектура клиентской части: роли `OfflineRepository`, `TasksApiOffline`, `SyncService`, `TaskDateCalculator`, `TodayTaskFilter`, `ReminderScheduler` и т.д.
   - Точки интеграции с UI (экран «Сегодня»/«Все задачи» и др.), без привязки к конкретному классу `MainActivity`.

3. `SYNC_ALGORITHM.md`
   - Формальное описание алгоритма синхронизации очереди событий с сервером.
   - Правила пересчёта задач на сервере при переходе между логическими днями.
   - Описание схемы разрешения конфликтов и требований к `timestamp`.

4. `OFFLINE_TEST_PLAN.md`
   - Список требуемых групп тестов: unit, интеграционные, e2e‑сценарии.
   - Описание ключевых сценариев (что тестируется), без жёсткой привязки к конкретным путям файлов и именам классов.

В `PLAN_OFFLINE_MODE.md` оставить только:
- краткое резюме целей,
- ссылки на перечисленные документы,
- высокоуровневый «порядок выполнения» этапов.

### 2. Канонические правила фильтрации задач

**Проблема**  
Правила фильтрации задач для вкладок «Сегодня» и «Все задачи» в текущем плане описаны в нескольких местах (исходные требования, Этап 1, раздел «Важные замечания по правилам фильтрации») разными формулировками. Это создаёт риск расхождений между реализацией на бэкенде и клиенте и усложняет сопровождение.

**Предлагаемое улучшение**  
Выделить единый канонический раздел со спецификацией правил фильтрации и ссылаться на него из всех остальных частей плана.

1. Создать раздел «Канонические правила фильтрации задач» (например, в `OFFLINE_REQUIREMENTS.md`) со следующей структурой:
   - Таблица или явное перечисление правил для комбинаций:
     - тип задачи: `one_time`, `recurring`, `interval`;
     - статус: `completed ∈ {true,false}`, `active ∈ {true,false}`;
     - положение `reminder_time` относительно логического дня: «в прошлом», «сегодня», «в будущем»;
     - целевая вкладка: «Сегодня», «Все задачи».
   - Для каждой комбинации явно указать, должна ли задача отображаться.
   - Для `one_time` задач зафиксировать обновлённые правила:
     - **Видна, если `reminder_time` сегодня или просрочена** — независимо от `completed` и `active`.
     - **Видна, если `completed = true`**, даже если `reminder_time` в будущем.
   - Для `recurring`/`interval` задач зафиксировать текущие правила:
     - Видна, если `reminder_time` сегодня или в прошлом (флаг `completed` на видимость не влияет).

2. В технических разделах (`OFFLINE_CLIENT_DESIGN.md`, `SYNC_ALGORITHM.md`, `OFFLINE_TEST_PLAN.md`) не дублировать правила в свободной форме, а ссылаться на канонический раздел, например:
   - «Фильтрация задач должна строго соответствовать разделу "Канонические правила фильтрации задач" в `OFFLINE_REQUIREMENTS.md`.»

3. Для тест‑плана:
   - Формулировать тест‑кейсы через ссылку на канонические правила (например: «проверить, что для всех комбинаций параметров из таблицы фильтрации результат соответствует ожидаемому значению `visible`»).
   - Добавить отдельный тест (на клиенте и на бэкенде), проверяющий, что реализация фильтрации покрывает все строки таблицы без расхождений.

### 3. Логический день, новый день и пересчёт раз в день

**Проблема**  
Текущее описание «нового дня» и пересчёта задач в плане дано текстом и не до конца формализовано: не очевидно, как именно определяется логический день с учётом `day_start_hour`, что происходит при пропущенных днях, при изменении `day_start_hour`, смене часового пояса и т.п. Отсутствуют явные инварианты, которые должны выполняться после пересчёта.

**Предлагаемое улучшение**  
Зафиксировать единое формальное определение логического дня и поведения пересчёта для клиента и сервера.

1. **Определение логического дня**
   - Логический день определяется как интервал длительностью 24 часа от одного значения `day_start_hour` до следующего.
   - Для любого локального времени `t` функция `logical_day(t, day_start_hour)` возвращает дату дня, с которым соответствующий интервал пересекается по времени больше всего.
   - На практике это означает, что:
     - логический день — это \[getDayStart(t, day_start_hour), getDayStart(t, day_start_hour) + 24h);
     - `logical_day_date` — календарная дата, в которой лежит большая часть этого интервала.
   - Функции `getDayStart` и `isNewDay` должны быть определены одинаково на клиенте и на сервере:
     - `prevStart = getDayStart(last_update, day_start_hour)`
     - `currStart = getDayStart(now, day_start_hour)`
     - `isNewDay = (currStart != prevStart)`.

2. **Пропущенные дни**
   - Предполагается, что в дни, когда приложение не запускалось, пользовательских событий (create/update/delete/complete/uncomplete) не было.
   - При первом запуске после паузы используется упрощённая стратегия пересчёта:
     - вычисляется `prevLD = logical_day(last_update, day_start_hour)` и `currLD = logical_day(now, day_start_hour)`;
     - если `currLD != prevLD`, выполняется **однократный пересчёт**, сразу приводящий состояние задач к виду на начало текущего логического дня;
     - не моделируется последовательный пересчёт по каждому пропущенному дню.
   - Это поведение зафиксировать как каноническое как для клиента, так и для сервера (сложный пошаговый вариант, проходящий по всем пропущенным дням, не используется, поскольку конечный результат пересчёта для заданной модели совпадает с упрощённым).

3. **Изменение `day_start_hour`**
   - При изменении настройки `day_start_hour` необходимо учитывать, что дата логического дня может измениться.
   - Рекомендуемый алгоритм:
     - хранить вместе с `last_update` значение `last_day_start_hour`, по которому он вычислялся;
     - при загрузке задач вычислять:
       - `oldLD = logical_day(last_update, last_day_start_hour)`,
       - `newLD = logical_day(now, current_day_start_hour)`;
     - если `newLD.date > oldLD.date` (дата логического дня сдвинулась вперёд) — считать, что наступил новый логический день, и выполнить пересчёт;
     - после успешного пересчёта обновить:
       - `last_update = now`,
       - `last_day_start_hour = current_day_start_hour`.
   - Изменение `day_start_hour` «назад», при котором дата логического дня не сдвигается вперёд, не вызывает пересчёта.

4. **Источник времени**
   - Все вычисления `logical_day`, `getDayStart`, `isNewDay` и сравнения `reminder_time` с «сегодня/прошлым/будущим» выполняются на основе **локального времени устройства** и текущего локального часового пояса ОС.
   - При смене часового пояса или ручном изменении системного времени:
     - дополнительные коррекции не выполняются;
     - возможные единичные аномалии (например, лишний или пропущенный пересчёт) считаются допустимыми в рамках продукта.
   - Дополнительно можно предусмотреть защиту от явно некорректного изменения времени (например, если `now << last_update` на несколько суток), но это не является обязательной частью требований.

5. **Инварианты после пересчёта**
   - После успешного пересчёта при наступлении нового логического дня должны выполняться следующие инварианты:
     - Общие:
       - `last_update` согласован с текущим логическим днём (по актуальному `day_start_hour`).
       - Не остаётся задач типа `recurring`/`interval` с `completed = true` и `reminder_time` раньше начала текущего логического дня.
     - Для `one_time` задач:
       - Если `completed = true` и `reminder_time` находился в прошлом логическом дне или ранее — устанавливается `active = false`, при этом `reminder_time` не изменяется.
       - Пересчёт никогда не изменяет `reminder_time` для `one_time` задач.
     - Для `recurring` задач:
       - Для всех задач с `type = recurring` и `completed = true` до пересчёта:
         - после пересчёта `completed = false`,
         - `reminder_time` указывает на следующее по правилам повторения вхождение относительно текущего логического дня и не меньше начала текущего логического дня.
     - Для `interval` задач:
       - Для задач с `type = interval` и `completed = true` до пересчёта:
         - после пересчёта `completed = false`,
         - `reminder_time = today_start + interval_days` (с сохранением времени или по логике бэкенда) и строго больше начала текущего логического дня.
   - Эти инварианты следует использовать:
     - в тест‑плане (проверка состояния задач сразу после пересчёта);
     - в клиентском коде (упрощение логики ReminderScheduler и фильтрации за счёт гарантированных свойств данных).

### 4. Архитектура клиента и разделение обязанностей

**Проблема**  
В текущем плане значительная часть ответственности за офлайн‑режим и пересчёт задач сосредоточена в UI‑слое (например, в `MainActivity`), а обязанности между `OfflineRepository`, `SyncService`, логикой пересчёта и `ReminderScheduler` размазаны. Это усложняет тестирование, ведёт к избыточной связности UI со слоем данных и повышает риск регрессий при доработках.

**Предлагаемое улучшение**  
Уточнить архитектуру клиентской части, введя явный сценарный слой (доменный фасад) и чётко разделив обязанности между компонентами.

1. Ввести доменный фасад/слой use‑case (например, `TaskManager`/`TasksInteractor`):
   - Отвечает за высокоуровневые сценарии:
     - загрузка задач для главного экрана (включая проверку нового дня, пересчёт, синхронизацию, обновление кэша, перепланирование уведомлений);
     - завершение/отмена завершения задач (`completeTask`/`uncompleteTask`), включая обновление кэша, постановку операций в очередь и перепланирование уведомлений.
   - UI‑слой (`MainActivity` и другие экраны) взаимодействует только с этим фасадом и не зависит напрямую от `OfflineRepository`, `SyncService`, `TaskDateCalculator`, `ReminderScheduler`.

2. Чётко развести обязанности по слоям:
   - `OfflineRepository`:
     - отвечает за доступ к локальному хранилищу (Room/SQLite, SharedPreferences и т.п.);
     - реализует CRUD по задачам, чтение/запись `last_update`, работу с очередью операций (добавление/чтение/удаление);
     - не содержит логики UI и не управляет уведомлениями.
   - `SyncService`:
     - отвечает за взаимодействие с сервером и обработку очереди синхронизации;
     - отправляет операции на сервер и получает актуальное состояние задач;
     - применяет полученное состояние к кэшу через `OfflineRepository`;
     - не реализует логику пересчёта по новому дню.
   - Сервис пересчёта задач (например, `TaskRecalculationService` или отдельный компонент, используемый фасадом):
     - инкапсулирует вызовы `TaskDateCalculator` и работу с `OfflineRepository.updateRecurringTasksForNewDay`;
     - реализует проверку `isNewDay` и применение инвариантов после пересчёта;
     - не зависит от UI и сети, что упрощает unit‑тестирование.
   - `ReminderScheduler`:
     - отвечает только за планирование и отмену локальных уведомлений на основе уже пересчитанных данных из кэша;
     - не изменяет задачи и не содержит собственной логики пересчёта дат (пересчёт централизован в сервисе пересчёта задач).

3. Сценарии работы через фасад:
   - Загрузка задач для главного экрана (условный `loadTasksForHomeScreen`):
     - при наличии сети — синхронизировать очередь операций через `SyncService` и при необходимости обновить кэшь задач с сервера;
     - проверить наступление нового логического дня и при необходимости выполнить пересчёт через сервис пересчёта задач;
     - обновить `last_update` и сохранить актуальные задачи в кэше;
     - перепланировать уведомления через `ReminderScheduler` на основе обновлённого списка задач;
     - вернуть задачи UI‑слою для отображения.
   - Завершение/отмена завершения задачи (`completeTask`/`uncompleteTask`):
     - обновить задачу в кэше через `OfflineRepository`;
     - добавить соответствующую операцию в очередь синхронизации;
     - перепланировать уведомления через `ReminderScheduler` (без пересчёта дат, он выполняется только при наступлении нового дня).

4. Тестируемость:
   - Сценарный слой (`TaskManager`/`TasksInteractor`) можно тестировать отдельно, подменяя зависимости:
     - `OfflineRepository` фейком в памяти;
     - `SyncService` заглушкой с предопределёнными ответами;
     - `ReminderScheduler` мок‑объектом, проверяющим только факты вызовов.
   - Логика пересчёта (`TaskDateCalculator` + сервис пересчёта задач) тестируется изолированно от UI и сети, что упрощает проверку инвариантов и поведения при новом дне.
   - Такое разделение уменьшает связность и снижает вероятность регрессий при изменениях в любом из слоёв.

### 5. Синхронизация, конфликты и флаг `changed`

**Проблема**  
Текущий план описывает общий алгоритм синхронизации и приоритет сервера, но поведение клиентского флага `changed` (задача изменена по итогам синхронизации) не формализовано. Важно, чтобы пользователь видел только действительно «новые» для него изменения, а чистый пересчёт задач на стороне сервера (новый день) не помечал задачи как изменённые.

**Предлагаемое улучшение**  
Явно определить, какие изменения считаются основанием для установки `changed = true`, и как отличать их от изменений, вызванных только пересчётом нового дня.

1. Семантика `changed` на клиенте:
   - `changed = true` означает, что состояние задачи на клиенте изменилось по итогам синхронизации с сервером **не только из‑за локальных действий пользователя и не только из‑за пересчёта нового дня**.
   - Пользователь должен иметь возможность увидеть такие задачи (например, отдельной меткой или списком) и явным действием подтвердить изменения, после чего флаг `changed` для соответствующих задач сбрасывается в `false`.

2. Основания для установки `changed = true`:
   - Изменения, вызванные:
     - событиями от других клиентов/устройств (create/update/delete/complete/uncomplete);
     - серверной бизнес‑логикой, которая модифицирует задачи сверх алгоритма пересчёта нового дня.
   - Не являются основанием для `changed`:
     - любые изменения полей задач, возникающие **только** в результате пересчёта по новому логическому дню на стороне сервера (сдвиг `reminder_time`, сброс `completed` у повторяющихся задач, установка `active=false` у завершённых `one_time` и т.п.).

3. Сравнение с локальным пересчётом (ключевое требование):
   - После успешной синхронизации клиент получает новое состояние задач от сервера.
   - Перед решением об установке `changed = true` клиент должен:
     - взять локальное состояние задач **после собственного пересчёта нового дня** (если он выполнялся офлайн);
     - сравнить его с полученным от сервера состоянием;
     - если различия между версиями задачи полностью объясняются только серверным пересчётом нового дня (и совпадают с ожидаемым результатом локального пересчёта), флаг `changed` **не устанавливается**;
     - если есть отличия, которые нельзя объяснить пересчётом (например, изменился текст, пользователь, тип/параметры повторения, статус в момент, когда клиент не был в курсе и т.п.), тогда для задачи устанавливается `changed = true`.
   - Таким образом, **обновление задач на стороне сервера, связанное только с наступлением нового дня, не активирует `changed`** — клиент сравнивает серверное состояние с ожидаемым результатом своего локального пересчёта и рассматривает его как «нормальное» развитие по времени.

4. UX‑поведение:
   - UI должен:
     - визуально выделять задачи с `changed = true`;
     - предоставлять пользователю понятный способ «подтвердить» изменения (открытие задачи, отдельная кнопка «Принять изменения» и т.п.), после чего флаг `changed` сбрасывается.
   - При последующих синхронизациях, если сервер снова изменит задачу сверх пересчёта нового дня, `changed` снова устанавливается по описанным правилам.


