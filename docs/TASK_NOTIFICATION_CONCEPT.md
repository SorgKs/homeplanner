# Концепция уведомлений по времени и пересчета задач

## Общая архитектура

Система состоит из трех независимых слоев времени:
1. **Реальное время** - системное время сервера
2. **Виртуальное время** - время для тестирования интерфейса (админ-режим)
3. **Время задач** - время бизнес-логики задач (всегда реальное)

## Пересчет задач

### Когда происходит пересчет:
- **Только при реальном новом дне**
- **Только завершенные задачи** пересчитываются
- **Триггер**: Запрос задач от фронтенда (`get_all_tasks`, `get_today_tasks`)

### Логика пересчета:
```python
def _recalculate_completed_tasks_on_new_day(db):
    if is_new_day(db):  # Проверка по РЕАЛЬНОМУ времени
        # Пересчитать завершенные задачи
        # Обновить last_update в РЕАЛЬНОМ времени
```

### Важно:
- Админ-режим НЕ вызывает пересчет
- Виртуальное время НЕ влияет на пересчет
- Пересчет происходит лениво (при запросе данных)

## Уведомления о новом дне

### Цель:
Уведомлять пользователей о новом дне даже если они не взаимодействуют с интерфейсом.

### Реализация: Планировщик + WebSocket

#### 1. Планировщик (`DayChangeScheduler`)
```python
class DayChangeScheduler:
    def _wait_for_next_day(self):
        # Вычислить время следующего дня + 1 минута
        tomorrow = get_day_start(real_now + timedelta(days=1)) + timedelta(minutes=1)
        wait_seconds = (tomorrow - real_now).total_seconds()
        await asyncio.sleep(wait_seconds)

        # Проверить и отправить уведомление
        if is_new_day(db):
            broadcast("day_changed", new_day=tomorrow.date())
```

#### 2. WebSocket уведомление
- **Событие**: `day_changed`
- **Полезная нагрузка**: `{"type": "day_changed", "new_day": "2026-01-10"}`
- **Получатели**: Все подключенные клиенты

#### 3. Обработка на фронтенде
```javascript
ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    if (msg.type === 'day_changed') {
        showToast(`Наступил новый день: ${msg.new_day}`);
        loadData(); // Перезагрузить задачи
    }
};
```

## Взаимодействие компонентов

### Сценарий 1: Реальный новый день
1. Планировщик ждет до 00:01 следующего дня
2. Отправляет WebSocket уведомление `day_changed`
3. Пользователь видит уведомление
4. При следующем взаимодействии задачи пересчитываются

### Сценарий 2: Админ-режим
1. Админ меняет виртуальное время
2. Интерфейс обновляется для тестирования
3. Задачи остаются неизменными
4. Пересчет не происходит

### Сценарий 3: Запрос данных в новом дне
1. Фронтенд запрашивает задачи
2. `is_new_day()` обнаруживает новый день
3. Пересчитываются завершенные задачи
4. Возвращаются обновленные данные

## Независимость слоев

### Реальное время:
- Управляет пересчетом задач
- Хранит `last_update`
- Определяет новый день

### Виртуальное время:
- Только для UI тестирования
- Не влияет на бизнес-логику
- Не сохраняется в базе

### Время задач:
- Всегда реальное время
- Независимо от виртуального
- Только для логики приложения

## Отказоустойчивость

### Планировщик:
- Перезапускается с сервером
- Ловит исключения
- Продолжает работу после ошибок

### WebSocket:
- Автоматическое переподключение
- Не блокирует основной функционал
- Graceful degradation

### Пересчет:
- Атомарные транзакции
- Логирование ошибок
- Fallback поведение

## Тестирование

### Пересчет задач:
- Изменить `last_update` в базе
- Запросить задачи
- Проверить пересчет

### Уведомления:
- Оставить вкладку открытой
- Дождаться нового дня
- Проверить WebSocket сообщения

### Админ-режим:
- Изменить виртуальное время
- Убедиться что задачи не пересчитались
- Проверить только UI изменения