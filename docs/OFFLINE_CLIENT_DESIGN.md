## OFFLINE_CLIENT_DESIGN

Высокоуровневая архитектура клиентской части офлайн‑режима.

> **Статус:** ✅ Миграция завершена, используется целевая архитектура  
> **Целевая архитектура:** См. [OFFLINE_FIRST_ARCHITECTURE.md](OFFLINE_FIRST_ARCHITECTURE.md)  
> **План миграции:** ✅ Завершена (см. [archive/MIGRATION_TO_LOCAL_API.md](archive/MIGRATION_TO_LOCAL_API.md))  
> **Последнее обновление:** 2025-12-28

### 1. Компоненты клиента (текущая реализация)

> **Примечание:** ✅ Миграция завершена. Используется `LocalApi` (см. целевую архитектуру в [OFFLINE_FIRST_ARCHITECTURE.md](OFFLINE_FIRST_ARCHITECTURE.md)).

- **OfflineRepository**
  - Локальное хранилище (Room/SQLite, SharedPreferences и т.п.).
  - CRUD по задачам, чтение/запись `last_update` и связанных метаданных.
  - Работа с очередью операций (добавление/чтение/удаление).
  - Не содержит логики UI и не управляет уведомлениями.

- ~~**TasksApiOffline**~~ ✅ (заменён на `LocalApi`, миграция завершена)
  - ~~Прослойка над обычным API задач~~ (удалена)
  - ✅ Используется `LocalApi` для работы с локальным хранилищем (см. [OFFLINE_FIRST_ARCHITECTURE.md](OFFLINE_FIRST_ARCHITECTURE.md))
  - **Статус:** ✅ Миграция завершена, компонент удалён (см. [archive/MIGRATION_TO_LOCAL_API.md](archive/MIGRATION_TO_LOCAL_API.md))

- **SyncService**
  - Обрабатывает очередь синхронизации.
  - Отправляет операции на сервер и получает актуальное состояние задач.
  - Применяет полученное состояние к кэшу через `OfflineRepository`.
  - Не реализует логику пересчёта по новому дню.

- **TaskDateCalculator**
  - Реализует логику `_calculate_next_due_date` с бэкенда для всех типов повторений.
  - Предоставляет `getDayStart` и `isNewDay` с учётом `day_start_hour`.

- **Сервис пересчёта задач** (например, `TaskRecalculationService`)
  - Инкапсулирует вызовы `TaskDateCalculator` и работу с `OfflineRepository.updateRecurringTasksForNewDay`.
  - Реализует проверку `isNewDay` и применение инвариантов после пересчёта.
  - Не зависит от UI и сети.

- **TodayTaskFilter**
  - Локальная фильтрация задач для вкладки «Сегодня».
  - Метод `filterTodayTasks(tasks, selectedUser, dayStartHour)`.
  - Логика строго следует «Каноническим правилам фильтрации задач» (`OFFLINE_REQUIREMENTS.md`).

- **ReminderScheduler**
  - Планирование и отмена локальных уведомлений.
  - Работает только с уже пересчитанными данными из кэша, сам пересчёт дат не выполняет.

- **Сценарный слой / фасад** (например, `TaskManager` / `TasksInteractor`)
  - Отвечает за высокоуровневые сценарии работы с задачами.
  - Инкапсулирует взаимодействие UI с `OfflineRepository`, `SyncService`,
    сервисом пересчёта и `ReminderScheduler`.

### 2. Основные сценарии через фасад

- **Загрузка задач для главного экрана** (условный `loadTasksForHomeScreen`):
  - При наличии сети:
    - синхронизировать очередь операций через `SyncService`;
    - при необходимости обновить кэш задач с сервера;
  - Проверить наступление нового логического дня и при необходимости выполнить пересчёт
    через сервис пересчёта задач;
  - Обновить `last_update` и сохранить актуальные задачи в кэше;
  - Перепланировать уведомления через `ReminderScheduler` на основе обновлённого списка задач;
  - Вернуть задачи UI‑слою для отображения (включая разбиение на «Сегодня» и «Все задачи»
    с помощью `TodayTaskFilter`).

- **Завершение/отмена завершения задачи** (`completeTask` / `uncompleteTask`):
  - Обновить задачу в кэше через `OfflineRepository`.
  - Добавить соответствующую операцию в очередь синхронизации.
  - Перепланировать уведомления через `ReminderScheduler`
    (без пересчёта дат — он выполняется только при наступлении нового дня).

### 3. Связь с офлайн‑режимом

- UI‑слой не знает о деталях синхронизации, пересчёта и очереди операций.
- Все решения по тому, когда пересчитывать задачи, когда синхронизироваться и как планировать уведомления,
  принимаются на уровне фасада и соответствующих сервисов.
- Такое разделение упрощает тестирование и снижает связность между UI и данными.

### 4. Фактическое поведение Android‑клиента (текущее состояние)

На данный момент реализация Android‑клиента следует концепции **offline‑first** на уровне данных, но UI вводит дополнительные ограничения:

- **Источник данных для UI**
  - Все списки задач (`Сегодня`, `Все задачи`) формируются **только из локального кэша Room** (`tasks_cache` через `OfflineRepository.loadTasksFromCache()`).
  - Сервер никогда не отрисовывает задачи напрямую в UI: онлайн‑запросы лишь обновляют кэш и очередь синхронизации.

- **Онлайн‑зависимые элементы UI**
  - Рендер вкладок «Сегодня» и «Все задачи» в `TasksScreen` сейчас зависит от `networkConfig`:
    - если `networkConfig == null`, UI показывает только сообщение «Подключение не настроено» и **не отображает список задач**, даже если кэш содержит N задач.
  - Вкладка «Сегодня» дополнительно опирается на `lastTodayTaskIds`, которые заполняются только после успешного онлайн‑фильтра «сегодня»:
    - при отсутствии таких ID (например, после первого запуска в офлайне) TODAY остаётся пустой, хотя в кэше есть задачи.

- **Следствие**
  - На уровне репозитория и сервисов стратегия соответствует offline‑first (все операции идут через локальное хранилище, сервер только синхронизирует).
  - На уровне UI поведение ближе к **"online‑required‑для‑отображения"**: без настроенного `networkConfig` и без первичного онлайн‑сеанса часть сценариев (вида «Сегодня», а также отображение списков при `networkConfig == null`) фактически недоступна, несмотря на наличие локального кэша.

Этот разрыв между архитектурным замыслом (полный offline‑first) и текущей реализацией UI должен учитываться при планировании доработок: упрощение условий рендера (основываясь только на локальном кэше) вернёт поведение к строго offline‑first модели.

### 5. Целевая архитектура (после миграции)

✅ Миграция завершена (см. [archive/MIGRATION_TO_LOCAL_API.md](archive/MIGRATION_TO_LOCAL_API.md)). Текущая архитектура:

- **LocalApi** (заменит `TasksApiOffline`)
  - **Назначение:** Работа с локальным хранилищем для UI
  - **Расположение:** `android/app/src/main/java/com/homeplanner/api/LocalApi.kt` (планируется)
  - **Ответственность:**
    - Загрузка данных из локального кэша (Room database)
    - Сохранение изменений в локальный кэш
    - Добавление операций в очередь синхронизации
    - Оптимистичные обновления для мгновенного отклика UI
  - **Методы:**
    - `suspend fun getTasks(activeOnly: Boolean = true): List<Task>`
    - `suspend fun createTask(task: Task, assignedUserIds: List<Int> = emptyList()): Task`
    - `suspend fun updateTask(taskId: Int, task: Task, assignedUserIds: List<Int> = emptyList()): Task`
    - `suspend fun completeTask(taskId: Int): Task`
    - `suspend fun uncompleteTask(taskId: Int): Task`
    - `suspend fun deleteTask(taskId: Int)`
  - **Особенности:**
    - Все методы работают только с локальным хранилищем
    - Не выполняет запросы к серверу
    - Все изменения автоматически добавляются в очередь синхронизации
    - Возвращает данные немедленно (оптимистичные обновления)

- **SyncService** (расширен)
  - Обрабатывает очередь синхронизации
  - Отправляет операции на сервер и получает актуальное состояние задач
  - Применяет полученное состояние к кэшу через `OfflineRepository`
  - **Новый метод:** `syncCacheWithServer()` — синхронизация кэша с сервером
  - См. подробное описание в [OFFLINE_FIRST_ARCHITECTURE.md](OFFLINE_FIRST_ARCHITECTURE.md)

- **TasksApi** (без изменений)
  - Прямые HTTP-запросы к серверу
  - Используется только `SyncService` для синхронизации

**Преимущества целевой архитектуры:**
- Чёткое разделение ответственности: `LocalApi` (UI) → `OfflineRepository` (хранилище), `SyncService` (синхронизация) → `TasksApi` (HTTP)
- Упрощение тестирования: каждый компонент можно тестировать изолированно
- Улучшение читаемости: понятно, где происходит работа с кэшем, а где с сервером
- Вся логика синхронизации сосредоточена в `SyncService`

**Сравнение с текущей архитектурой:**
- `TasksApiOffline` объединяет работу с кэшем и синхронизацию → `LocalApi` только работа с кэшем
- Синхронизация разбросана между `TasksApiOffline` и `SyncService` → вся синхронизация в `SyncService`
- Сложнее тестировать → каждый компонент тестируется изолированно

Подробное описание целевой архитектуры см. в [OFFLINE_FIRST_ARCHITECTURE.md](OFFLINE_FIRST_ARCHITECTURE.md).

{
  "cells": [],
  "metadata": {
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}
