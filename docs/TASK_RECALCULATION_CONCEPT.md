# Концепция пересчета задач при наступлении нового дня

## Общая концепция

Пересчет задач должен происходить **независимо от админ-режима** и основываться исключительно на **реальном системном времени**. Админ-режим используется только для тестирования и не влияет на бизнес-логику.

## Когда происходит пересчет

Пересчет задач происходит при наступлении нового дня в реальном времени. Новый день определяется по `day_start_hour` из конфигурации (по умолчанию 3:00).

Пересчет может быть вызван двумя способами:
1. **По таймеру**: `DayChangeScheduler` запускается раз в сутки через минуту после наступления нового дня
2. **При запросах API**: проверка происходит при ЛЮБЫХ запросах API через middleware

### Условия пересчета:
1. `last_update` (время последнего пересчета) находится в предыдущем дне относительно текущего времени
2. Пересчет происходит только один раз в день
3. Дублирование предотвращено через проверку `is_new_day()`

## Архитектура пересчета

### Основные компоненты:

1. **`is_new_day(db: Session) -> bool`** (`backend/utils/date_utils.py`)
   - Проверяет, наступил ли новый день
   - Использует `last_update` из AppMetadata
   - Сравнивает день старта последнего обновления с текущим днем старта

2. **`check_new_day(db: Session, ws_manager=None) -> bool`** (`backend/services/task_service.py`)
   - Комплексная проверка нового дня с пересчетом и уведомлениями
   - Вызывает `is_new_day()` для проверки
   - При обнаружении нового дня вызывает `recalculate_tasks()` и отправляет WebSocket уведомление (если ws_manager передан)
   - Возвращает True если пересчет был выполнен

3. **`recalculate_tasks(db: Session) -> None`** (`backend/services/task_service.py`)
   - Основная функция пересчета завершенных задач
   - Находит ВСЕ завершенные задачи (`completed = True`) с reminder_time в прошлом
   - Пересчитывает даты для повторяющихся задач по типам
   - Сбрасывает статус `completed = False` для recurring/interval задач
   - Деактивирует one-time задачи (`enabled = False`)
   - Обновляет `last_update` на текущее реальное время через `set_last_update`

4. **`set_last_update(db: Session, timestamp: datetime | None = None, commit: bool = False) -> None`** (`backend/utils/date_utils.py`)
   - Сохраняет время последнего пересчета в AppMetadata
   - Всегда использует реальное время (не виртуальное)
   - Поддерживает транзакционный режим через параметр commit

## Места вызова пересчета
### 1. `TaskRecalculationMiddleware` (`backend/main.py`)
- **Назначение**: Middleware для проверки нового дня при любых API запросах
- **Когда вызывается**: При каждом HTTP запросе к API эндпоинтам (начинающимся с `/api/`)
- **Почему здесь**: Обеспечивает проверку и пересчет задач при любом взаимодействии пользователя с сервером

### 2. `DayChangeScheduler.check_and_notify()` (`backend/services/day_change_scheduler.py`)
- **Назначение**: Автоматический пересчет задач по таймеру
- **Когда вызывается**: Раз в сутки через минуту после наступления нового дня
- **Почему здесь**: Обеспечивает пересчет задач даже без пользовательских запросов

## Логика пересчета по типам задач

### Для завершенных задач (`completed = True`):
**Все завершенные задачи сбрасываются независимо от `reminder_time`.**

1. **Разовые задачи** (`task_type = "one_time"`):
   - `enabled = False` (деактивация задачи)
   - Дата не меняется

2. **Повторяющиеся задачи** (`task_type = "recurring"`):
   - Пересчет `reminder_time` на следующую дату по расписанию
   - `completed = False` (активация для следующего выполнения)

3. **Интервальные задачи** (`task_type = "interval"`):
   - Добавление `interval_days` к текущему времени
   - `completed = False`

## Хранение времени последнего обновления

- **`last_update`** хранится в таблице `AppMetadata` с ключом `"last_task_update"`
- **Формат**: Реальное системное время (datetime)
- **Обновляется**: После каждого успешного пересчета
- **Используется**: Для определения, был ли уже выполнен пересчет в текущем дне

## Отказоустойчивость

- Пересчет происходит в транзакции
- Если пересчет не удался, изменения откатываются
- Ошибки логируются, но не прерывают работу API
- Повторные вызовы не вызывают дублированный пересчет

## Независимость от админ-режима

- Админ-режим не влияет на логику пересчета
- Виртуальное время не используется для определения "нового дня"
- Пересчет основан только на реальном времени
- Админ-режим предназначен только для тестирования интерфейса

## Автоматическое обновление интерфейса

### Проблема:
Если пользователь не взаимодействует с интерфейсом при наступлении нового дня, задачи не обновятся автоматически.

### Решение: WebSocket уведомления

#### 1. Планировщик нового дня (`DayChangeScheduler`) (`backend/services/day_change_scheduler.py`)
- **Назначение**: Периодическая проверка наступления нового дня
- **Методы**:
  - `start()` - запускает фоновый поток проверки
  - `check_and_notify()` - проверяет новый день и отправляет уведомления
- **Когда запускается**: При старте приложения в `backend/main.py` через lifespan
- **Когда останавливается**: При завершении приложения

#### 2. Автоматический пересчет задач
- **Выполняется**: Автоматически при обнаружении нового дня
- **Функция**: `_recalculate_completed_tasks_on_new_day(db, force=True)`
- **Результат**: Задачи пересчитываются независимо от пользовательских запросов

#### 3. WebSocket уведомление
- **Тип сообщения**: `{"type": "day_changed", "new_day": "2026-01-10", "timestamp": "2026-01-10T00:00:00"}`
- **Отправляется**: Через `ConnectionManager.broadcast()`
- **Условие**: После реального обновления

#### 3. Обработка на фронтенде (`frontend/websocket.js`)
- **Обработчик**: В `ws.onmessage` для `msg.type === 'day_changed'`
- **Действия**:
  - Показ уведомления пользователю с датой нового дня
  - Вызов `loadData()` для обновления всех задач
- **Результат**: Автоматическое обновление интерфейса без участия пользователя





## Тестирование

Пересчет можно протестировать:
1. Установив `last_update` в прошлое через базу данных
2. Вызвав `get_all_tasks()` или `get_today_tasks()`
3. Проверив, что завершенные задачи пересчитаны

Автоматическое обновление тестируется:
1. Оставив вкладку открытой на ночь
2. Проверив WebSocket сообщения
3. Убедившись в автоматическом обновлении интерфейса