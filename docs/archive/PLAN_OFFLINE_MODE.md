# План работ: Переход на офлайн-режим как основной режим работы

## Структура документов

Этот документ теперь является **высокоуровневым планом**, а детальные требования и дизайн вынесены
в отдельные файлы:

- `OFFLINE_REQUIREMENTS.md` — бизнес‑/функциональные требования, логический день и канонические правила фильтрации.
- `OFFLINE_CLIENT_DESIGN.md` — архитектура клиентской части и основные сценарии.
- `SYNC_ALGORITHM.md` — формальный алгоритм синхронизации клиента с сервером.
- `OFFLINE_TEST_PLAN.md` — тест‑план (unit, интеграционные, e2e‑сценарии).

При доработке реализации следует в первую очередь обновлять эти документы, а данный план
использовать как оглавление и дорожную карту.

## Исходные требования

### 1. Основной режим работы — офлайн
- Приложение должно корректно работать при отсутствии сети.
- Все ключевые сценарии (просмотр задач, подтверждение, уведомления) должны быть доступны в офлайне.

### 2. Отображение задач
- На вкладке **"Сегодня"**:
  - Должны корректно отображаться задачи, относящиеся к текущему «дню» (с учетом `day_start_hour`).
  - Для `one_time` задач:
    - Видна, если `reminder_time` сегодня или просрочена — **независимо от** `completed` и `active`.
    - Видна, если `completed=true` — **даже если** `reminder_time` в будущем.
  - Для `recurring`/`interval` задач:
    - Если `completed=true` — видна, если `reminder_time` сегодня или просрочена (завершена сегодня).
    - Если `completed=false` — видна, если `reminder_time` сегодня или просрочена.
- На вкладке **"Все задачи"**:
  - Должны корректно отображаться все задачи с учетом их актуальных свойств (`active`, `completed`, `reminder_time` и т.д.).

### 3. Уведомления
- В офлайне должны корректно срабатывать локальные уведомления при достижении времени `reminder_time`.
- Повторяющиеся и интервальные задачи должны получать корректно пересчитанные будущие `reminder_time`, чтобы уведомления продолжали работать без связи с сервером.
- Завершенные задачи не должны порождать новые уведомления.

### 4. Подтверждение задач (complete/uncomplete)
- В офлайне должны корректно устанавливаться и сниматься подтверждения задач (`completed`).
- Для `one_time` задач:
  - При пересчете нового дня завершенная задача должна становиться неактивной (`active=false`), дата не меняется.
- Для `recurring`/`interval` задач:
  - При новом дне выполняется пересчет следующей даты и сброс `completed=false` (задача «переезжает» на следующую итерацию).

### 5. Пересчет дат при наступлении нового дня
- Пересчет должен выполняться **разово при наступлении нового дня** (по `day_start_hour`), а не при каждом обращении.
- Логика пересчета на клиенте должна быть согласована с бэкендом:
  - `one_time`: дата не меняется, но завершенные задачи становятся неактивными.
  - `recurring`: следующая дата рассчитывается через `_calculate_next_due_date`, `completed` сбрасывается.
  - `interval`: следующая дата `today + interval_days` с сохранением времени, `completed` сбрасывается.

### 6. Стратегия синхронизации
- **Сервер — приоритетный источник данных**:
  - Клиент не пытается «навязать» серверу результаты пересчета.
  - Клиент отправляет только события (create/update/delete/complete/uncomplete), сервер применяет их.
- При новом дне:
  - Сервер самостоятельно выполняет пересчет задач на основе своей модели и `last_update`.
  - Клиент полноценно атономно работает при отсутствии связи с сервером, но при наличии сети должен перезагружать состояние с сервера.
- Алгоритм синхронизации должен быть единым и учитывать любые комбинации:
  - События за предыдущий и текущий день.
  - События до и после пересчета на сервере.
  - Офлайн/онлайн переходы и отложенные события.

### 7. Тестируемость
- Все новые функции (фильтрация, пересчет, офлайн-хранилище, синхронизация, уведомления) должны быть покрыты unit- и интеграционными тестами.
- Отдельно должны быть покрыты сложные сценарии:
  - События за предыдущий день и пересчет нового дня.
  - Офлайн пересчет с последующей синхронизацией.
  - Множественные события с разными `timestamp` в рамках нескольких дней.

## Текущее состояние

### Что уже работает:
1. **Offline-first архитектура**: `TasksApiOffline` загружает данные из кэша и синхронизирует в фоне
2. **Локальное хранилище**: `OfflineRepository` сохраняет задачи в Room/SQLite
3. **Очередь синхронизации**: операции сохраняются в очередь и синхронизируются при наличии сети
4. **Базовое отображение**: задачи загружаются из кэша

### Проблемы для решения:

#### 1. Отображение задач на вкладках "Сегодня" и "Все задачи"
**Текущая ситуация:**
- Вкладка "Сегодня" зависит от `getTodayTaskIds()` с сервера
- В офлайне используется `lastTodayTaskIds` (кэшированные ID с последней синхронизации)
- При отсутствии сети или устаревших ID вкладка "Сегодня" может быть пустой или некорректной

**Требуется:**
- Реализовать локальную фильтрацию задач по правилам "сегодня" (аналогично `TaskService.get_tasks_for_today()`)
- **ВАЖНО:** Обновить правила фильтрации как для оффлайна, так и для бэкенда
- Правила фильтрации:
  - `one_time`: 
    - Видна если `reminder_time` сегодня или просрочена (в прошлом) - **БЕЗ дополнительных условий** (независимо от `completed` или `active`)
    - Видна если `completed=true` - **даже если `reminder_time` в будущем**
  - `recurring/interval`: 

#### 2. Уведомления при достижении времени
**Текущая ситуация:**
- `ReminderScheduler` планирует уведомления на основе `reminderTime` из кэша
- Для повторяющихся задач `reminderTime` может быть в прошлом (не пересчитан)
- Уведомления не срабатывают для задач с устаревшими датами

**Требуется:**
- Перед планированием уведомлений проверять, не устарела ли дата
- Для повторяющихся задач пересчитывать следующее время уведомления локально
- Учитывать, что задача может быть завершена (не планировать для завершенных)

#### 3. Установка/снятие подтверждений задач (complete/uncomplete)
**Текущая ситуация:**
- Операции `completeTask`/`uncompleteTask` работают через `TasksApiOffline`
- Задача обновляется в кэше локально
- НО: для повторяющихся задач не пересчитывается следующая дата после завершения

**Требуется:**
- После `completeTask`/`uncompleteTask`:
  - Перепланировать уведомления (отменить для завершенных, запланировать для незавершенных)
- **ВАЖНО:** Пересчет `reminder_time` для повторяющихся задач НЕ выполняется при завершении
- Пересчет происходит только при наступлении нового дня (см. раздел 4)

#### 4. Пересчет дат и времен при наступлении нового дня
**Текущая ситуация:**
- Пересчет дат выполняется на бэкенде в `TaskService._is_new_day()` и `TaskService.get_all_tasks()`
- **Логика бэкенда:** Пересчет происходит **разово при наступлении нового дня** (по `day_start_hour`)
- При наступлении нового дня:
  - Для **всех завершенных** (`completed=true`) повторяющихся задач:
    - Для `recurring` задач пересчитывается `reminderTime` на следующее вхождение
    - Для `interval` задач пересчитывается `reminderTime` на `today + interval_days`
    - Сбрасывается флаг `completed=false` для повторяющихся задач
  - Для `one_time` задач:
    - Если `completed=true` → устанавливается `active=false` (задача становится неактивной)
    - Дата `reminder_time` НЕ изменяется
- В офлайне эта логика не выполняется

**Требуется:**
- Реализовать локальную проверку наступления нового дня (аналогично `TaskService._is_new_day()`)
- Хранить `last_update` timestamp в `OfflineRepository` (SharedPreferences или metadata)
- **ВАЖНО:** Пересчет выполняется **только один раз в день** при первой загрузке после наступления нового дня
- При загрузке задач проверять, наступил ли новый день (сравнение `last_update` с текущим днем по `day_start_hour`)
- Если новый день:
  - Для **всех завершенных** (`completed=true`) задач:
    - Для `recurring` задач: пересчитать `reminderTime`, сбросить `completed=false`
    - Для `interval` задач: пересчитать `reminderTime`, сбросить `completed=false`
    - Для `one_time` задач: установить `active=false` (дата не изменяется)
  - Обновить задачи в кэше
  - Обновить `last_update` timestamp
  - Перепланировать уведомления
- Если новый день НЕ наступил - пересчет НЕ выполняется

## План реализации

### Этап 1: Обновление правил фильтрации "Сегодня" (бэкенд + оффлайн)

**Файлы для изменения:**
- `backend/services/task_service.py` - обновить `get_tasks_for_today()`
- `android/app/src/main/java/com/homeplanner/MainActivity.kt`
- Создать: `android/app/src/main/java/com/homeplanner/utils/TodayTaskFilter.kt`

**Задачи:**
1. **Обновить бэкенд** (`backend/services/task_service.py`):
   - Изменить логику фильтрации `one_time` в `get_tasks_for_today()`:
     - Убрать проверку `task.active`
     - Видна если `reminder_time` сегодня или просрочена (любая задача)
     - Видна если `completed=true` (даже если в будущем)
   - Обновить логику пересчета в `get_all_tasks()`:
     - Для завершенных `one_time` задач устанавливать `active=false` при новом дне
2. **Создать утилиту для Android** `TodayTaskFilter`:
   - Метод `filterTodayTasks(tasks, selectedUser, dayStartHour)`
   - Реализовать логику фильтрации:
     - `one_time`: видна если `reminder_time` сегодня/просрочена ИЛИ `completed=true`
     - `recurring/interval`: видна если `reminder_time` сегодня/просрочена (с учетом `completed`)
   - Учитывать `day_start_hour` (из настроек или по умолчанию)
   - Определять "сегодня" относительно `day_start_hour`
3. В `MainActivity.kt`:
   - Заменить использование `lastTodayTaskIds` на локальную фильтрацию
   - Использовать `TodayTaskFilter.filterTodayTasks()` для вкладки "Сегодня"
   - Убрать зависимость от `getTodayTaskIds()` для офлайн-режима

**Критерии готовности:**
- Бэкенд использует новые правила фильтрации для `one_time`
- Вкладка "Сегодня" корректно показывает задачи в офлайне
- Фильтрация соответствует обновленным правилам
- Работает без зависимости от сервера
- Завершенные `one_time` задачи видны даже если в будущем

---

### Этап 2: Пересчет дат для повторяющихся задач (разово при новом дне)

**Файлы для изменения:**
- Создать: `android/app/src/main/java/com/homeplanner/utils/TaskDateCalculator.kt`
- `android/app/src/main/java/com/homeplanner/repository/OfflineRepository.kt`

**Задачи:**
1. Создать `TaskDateCalculator` с методами:
   - `calculateNextDueDate(task, currentDate, dayStartHour)` - пересчет следующей даты
   - Реализовать логику из `TaskService._calculate_next_due_date()`:
     - Поддержка `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`, `WEEKDAYS`, `WEEKENDS`, `MONTHLY_WEEKDAY`, `YEARLY_WEEKDAY`
     - Поддержка `interval` задач (пересчет на `today + interval_days`)
   - `getDayStart(dateTime, dayStartHour)` - определение начала дня (аналогично `TaskService._get_day_start()`)
   - `isNewDay(lastUpdate, currentTime, dayStartHour)` - проверка наступления нового дня (аналогично `TaskService._is_new_day()`)
2. В `OfflineRepository`:
   - Добавить методы для работы с `last_update` timestamp:
     - `getLastUpdateTimestamp(): Long?` - получить последний timestamp обновления
     - `setLastUpdateTimestamp(timestamp: Long)` - установить timestamp обновления
   - Добавить метод `updateRecurringTasksForNewDay(dayStartHour): Boolean`:
     - Проверка наступления нового дня через `TaskDateCalculator.isNewDay()`
     - **Если новый день НЕ наступил - вернуть `false` без изменений**
     - Если новый день наступил:
       - Получить все задачи из кэша с `completed=true`
       - Для каждой завершенной задачи:
         - Для `recurring` задач:
           - Пересчитать `reminderTime` через `TaskDateCalculator.calculateNextDueDate()`
           - Сбросить `completed=false`
           - Обновить задачу в кэше
         - Для `interval` задач:
           - Пересчитать `reminderTime` на `today + interval_days`
           - Сбросить `completed=false`
           - Обновить задачу в кэше
         - Для `one_time` задач:
           - Установить `active=false` (дата `reminder_time` не изменяется)
           - Обновить задачу в кэше
       - Обновить `last_update` timestamp
       - Вернуть `true` (обновления были выполнены)

**Критерии готовности:**
- Логика пересчета дат полностью соответствует бэкенду
- Пересчет выполняется **только один раз в день** при наступлении нового дня
- Корректно обрабатываются все типы задач:
  - `recurring`: пересчет даты, сброс `completed=false`
  - `interval`: пересчет даты, сброс `completed=false`
  - `one_time`: установка `active=false` (дата не изменяется)
- Новый день определяется по `day_start_hour` (аналогично бэкенду)

---

### Этап 3: Интеграция пересчета дат в загрузку задач (разово в день)

**Файлы для изменения:**
- `android/app/src/main/java/com/homeplanner/MainActivity.kt`
- `android/app/src/main/java/com/homeplanner/api/TasksApiOffline.kt`
- `android/app/src/main/java/com/homeplanner/sync/SyncService.kt`
- `android/app/src/main/java/com/homeplanner/repository/OfflineRepository.kt`

**Задачи:**
1. В `MainActivity.loadTasks()`:
   - После загрузки задач из кэша проверить наступление нового дня
   - **ВАЖНО:** Перед пересчетом выполнить синхронизацию состояния (см. подэтап 3.1)
   - Вызвать `offlineRepository.updateRecurringTasksForNewDay(dayStartHour)`
   - Метод вернет `true` только если был выполнен пересчет (новый день наступил)
   - Если пересчет был выполнен (`true`):
     - Перезагрузить задачи из кэша (чтобы получить обновленные даты)
     - Обновить `allTasks` и `tasks`
     - Перепланировать уведомления через `reminderScheduler`
   - Если пересчет НЕ был выполнен (`false`) - ничего не делать
2. В `TasksApiOffline.getTasks()`:
   - После загрузки из кэша НЕ вызывать пересчет (пересчет только в `MainActivity.loadTasks()`)
   - Это гарантирует, что пересчет происходит только один раз при загрузке
3. При старте приложения:
   - При первой загрузке автоматически проверится наступление нового дня
   - Пересчет выполнится только если новый день действительно наступил

**Подэтап 3.1: Единый алгоритм синхронизации состояния**

**Принципы:**
- **Сервер является приоритетным источником данных** - версия на сервере считается актуальной
- Клиент отправляет очередь событий на сервер, сервер применяет их
- **ВАЖНО:** Операции пересчета задач НЕ отправляются на сервер - сервер сам выполняет пересчет при новом дне
- После пересчета на клиенте задачи обновляются в локальном кэше только для отображения
- После синхронизации очереди клиент загружает обновленное состояние с сервера (включая пересчитанные даты)

**Единый алгоритм синхронизации (учитывает все варианты):**
Алгоритм должен корректно обрабатывать любые комбинации:
- События за предыдущий день и текущий день
- События до и после пересчета на сервере
- События до и после пересчета на клиенте
- Офлайн и онлайн режимы

**Задачи:**

**На клиенте:**
1. В `OfflineRepository.addToSyncQueue()`:
   - Убедиться, что операция сохраняется с корректным `timestamp` (время создания операции на клиенте)
   - `timestamp` должен отражать реальное время выполнения операции, а не время добавления в очередь
2. В `OfflineRepository.updateRecurringTasksForNewDay()`:
   - После пересчета каждой задачи обновить задачу в кэше
   - **ВАЖНО:** Операции `update` для пересчитанных задач НЕ добавляются в очередь синхронизации
   - Сервер сам выполнит пересчет при новом дне, клиенту нужно только загрузить обновленное состояние
3. В `SyncService.syncQueue()`:
   - При отправке операций на сервер передавать `timestamp` каждой операции
   - Операции должны отправляться отсортированными по `timestamp` (хронологический порядок)
   - Операции отправляются все сразу (не батчами по дням)
4. Создать метод `SyncService.syncStateBeforeRecalculation()`:
   - Проверить наличие операций в очереди (`offlineRepository.getPendingOperationsCount() > 0`)
   - Если есть операции:
     - Выполнить полную синхронизацию очереди через `syncQueue()`
     - Дождаться завершения всех операций
   - Загрузить актуальное состояние задач с сервера через `tasksApi.getTasks(activeOnly=false)`
   - Сохранить задачи в кэш через `offlineRepository.saveTasksToCache()`
   - Вернуть `true` если синхронизация выполнена, `false` если офлайн
5. В `MainActivity.loadTasks()` перед пересчетом:
   - Если новый день наступил И есть соединение:
     - Вызвать `syncService.syncStateBeforeRecalculation()`:
       - Синхронизировать очередь операций (если есть)
       - Загрузить актуальное состояние с сервера
     - Выполнить пересчет через `offlineRepository.updateRecurringTasksForNewDay()`:
       - Пересчет обновит задачи в локальном кэше (для отображения)
       - Операции `update` НЕ добавляются в очередь (сервер сам пересчитает)
     - Если есть соединение:
       - Выполнить синхронизацию очереди через `syncService.syncQueue()` (только для других операций, не пересчет)
       - Загрузить обновленное состояние с сервера (сервер пересчитал даты при новом дне)
       - Сохранить в кэш через `offlineRepository.saveTasksToCache()` (перезаписать локальный пересчет)
   - Если новый день наступил, но НЕТ соединения:
     - Выполнить пересчет локально (для отображения)
     - При восстановлении соединения загрузить обновленное состояние с сервера (сервер пересчитал даты)

**На сервере (требования к бэкенду):**
1. При получении очереди событий от клиента:
   - Сортировать все события по `timestamp` в хронологическом порядке (независимо от дня)
   - Определить `day_start_hour` из настроек
2. Единый алгоритм обработки событий:
   - Инициализировать переменную `lastProcessedDay` = день последнего события (или текущий день, если событий нет)
   - Для каждого события в хронологическом порядке:
     - Определить день события по `timestamp` и `day_start_hour`
     - Если день события отличается от `lastProcessedDay`:
       - Если `lastProcessedDay` был предыдущим днем, а текущее событие относится к новому дню:
         - Выполнить пересчет задач для нового дня (аналогично `TaskService.get_all_tasks()`)
         - Обновить `last_update` timestamp
       - Обновить `lastProcessedDay` = день текущего события
     - Применить событие к соответствующей задаче
   - После обработки всех событий:
     - Если последнее обработанное событие было за предыдущий день, а текущий день уже наступил:
       - Выполнить пересчет задач для нового дня
       - Обновить `last_update` timestamp
3. Возврат результата:
   - После обработки всех событий вернуть обновленное состояние задач клиенту

**Критерии готовности:**
- При загрузке задач автоматически проверяется наступление нового дня
- Перед пересчетом синхронизируется очередь операций (если есть) и загружается актуальное состояние с сервера
- После синхронизации очереди загружается обновленное состояние с сервера (сервер тоже пересчитал даты)
- Сервер является приоритетным источником - финальное состояние берется с сервера
- Пересчет выполняется **только один раз в день** (при первой загрузке после наступления нового дня)
- Завершенные задачи обрабатываются только при наступлении нового дня:
  - Повторяющиеся задачи получают новые даты и сброс `completed=false`
  - Разовые задачи становятся неактивными (`active=false`)
- Если новый день не наступил - пересчет не выполняется, задачи остаются без изменений
- В офлайне пересчет выполняется локально, операции остаются в очереди для синхронизации

---

### Этап 4: Перепланирование уведомлений после завершения задач

**Файлы для изменения:**
- `android/app/src/main/java/com/homeplanner/api/TasksApiOffline.kt`
- `android/app/src/main/java/com/homeplanner/MainActivity.kt`

**Задачи:**
1. В `TasksApiOffline.completeTask()`:
   - После обновления задачи в кэше (установка `completed=true`) ничего дополнительного не делать
   - **ВАЖНО:** Пересчет `reminder_time` НЕ выполняется при завершении задачи
   - Пересчет произойдет автоматически при наступлении нового дня (см. Этап 3)
2. В `MainActivity`:
   - После `completeTask`/`uncompleteTask`:
     - Перепланировать уведомления через `reminderScheduler.cancelAll()` и `reminderScheduler.scheduleForTasks()`
     - Это отменит уведомления для завершенных задач и запланирует для незавершенных

**Критерии готовности:**
- После завершения задачи обновляется только статус `completed=true` в кэше
- Пересчет `reminder_time` НЕ выполняется при завершении (только при новом дне)
- Уведомления корректно перепланируются (отменяются для завершенных)

---

### Этап 5: Перепланирование уведомлений

**Файлы для изменения:**
- `android/app/src/main/java/com/homeplanner/ReminderScheduler.kt`
- `android/app/src/main/java/com/homeplanner/MainActivity.kt`

**Задачи:**
1. В `ReminderScheduler.scheduleForTaskIfUpcoming()`:
   - Перед планированием проверять, не устарела ли дата
   - Для повторяющихся задач с датой в прошлом:
     - Пересчитать следующую дату через `TaskDateCalculator`
     - Обновить задачу в кэше (или использовать пересчитанную дату только для планирования)
2. В `MainActivity`:
   - После любых изменений задач (загрузка, завершение, обновление) перепланировать уведомления
   - Использовать актуальные даты из кэша

**Критерии готовности:**
- Уведомления планируются только для будущих дат
- Для повторяющихся задач с устаревшими датами автоматически пересчитывается следующая дата
- Уведомления корректно срабатывают в офлайне

---

### Этап 6: Тестирование и отладка

**Файлы для создания/изменения:**
- `android/app/src/androidTest/java/com/homeplanner/utils/TodayTaskFilterTest.kt`
- `android/app/src/androidTest/java/com/homeplanner/utils/TaskDateCalculatorTest.kt`
- `android/app/src/androidTest/java/com/homeplanner/repository/OfflineRepositoryRecalculationTest.kt`
- `android/app/src/androidTest/java/com/homeplanner/sync/SyncServiceRecalculationTest.kt`
- `android/app/src/androidTest/java/com/homeplanner/integration/OfflineModeIntegrationTest.kt`
- `tests/test_task_service.py` - добавить тесты для новых правил фильтрации `one_time`

**Задачи:**

**1. Unit-тесты для новых компонентов:**
- `TodayTaskFilterTest.kt`:
  - Тест фильтрации `one_time` задач (видна если `reminder_time` сегодня/просрочена ИЛИ `completed=true`)
  - Тест фильтрации `recurring/interval` задач
  - Тест учета `day_start_hour` при определении "сегодня"
  - Тест пустого списка задач
  - Тест задач с разными статусами (`completed`, `active`)
- `TaskDateCalculatorTest.kt`:
  - Тест `calculateNextDueDate()` для всех типов повторений (`DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`, `WEEKDAYS`, `WEEKENDS`, `MONTHLY_WEEKDAY`, `YEARLY_WEEKDAY`)
  - Тест `calculateNextDueDate()` для `interval` задач
  - Тест `getDayStart()` с разными `day_start_hour`
  - Тест `isNewDay()` для различных сценариев (новый день наступил/не наступил)
  - Тест граничных случаев (полночь, переход через день)
- `OfflineRepositoryRecalculationTest.kt`:
  - Тест `updateRecurringTasksForNewDay()` для `recurring` задач
  - Тест `updateRecurringTasksForNewDay()` для `interval` задач
  - Тест `updateRecurringTasksForNewDay()` для `one_time` задач (установка `active=false`)
  - Тест, что метод возвращает `false` если новый день не наступил
  - Тест обновления `last_update` timestamp
  - Тест, что операции пересчета НЕ добавляются в очередь синхронизации

**2. Интеграционные тесты синхронизации:**
- `SyncServiceRecalculationTest.kt`:
  - Тест `syncStateBeforeRecalculation()` при наличии операций в очереди
  - Тест `syncStateBeforeRecalculation()` при пустой очереди
  - Тест `syncStateBeforeRecalculation()` в офлайне
  - Тест синхронизации очереди с событиями за разные дни
  - Тест загрузки обновленного состояния после синхронизации

**3. Тесты сложных сценариев синхронизации:**
- `OfflineModeIntegrationTest.kt`:
  - **Сценарий 1:** События за предыдущий день + новый день наступил
    - Создать события за предыдущий день на клиенте
    - Симулировать наступление нового дня
    - Проверить, что сервер применяет события за предыдущий день, затем пересчитывает, затем применяет события нового дня
  - **Сценарий 2:** События только за текущий день
    - Создать события только за текущий день
    - Проверить, что сервер применяет события без пересчета
  - **Сценарий 3:** События за оба дня (предыдущий + текущий)
    - Создать события за предыдущий и текущий день
    - Проверить хронологическую обработку и пересчет между днями
  - **Сценарий 4:** События до и после пересчета на сервере
    - Создать события с `timestamp` до и после времени пересчета
    - Проверить, что пересчет выполняется в правильный момент
  - **Сценарий 5:** Офлайн пересчет + восстановление соединения
    - Выполнить пересчет в офлайне
    - Восстановить соединение
    - Проверить, что загружается состояние с сервера (сервер пересчитал)
  - **Сценарий 6:** Множественные клиенты с событиями за разные дни
    - Симулировать несколько клиентов с событиями за разные дни
    - Проверить корректную обработку на сервере

**4. Тесты функциональности:**
- Тесты отображения задач:
  - Вкладка "Сегодня" корректно показывает задачи в офлайне
  - Вкладка "Все задачи" показывает все задачи
  - Фильтрация соответствует правилам (включая новые правила для `one_time`)
  - Переключение между вкладками работает корректно
- Тесты завершения задач:
  - Завершение `one_time` задачи
  - Завершение `recurring` задачи (без пересчета даты)
  - Завершение `interval` задачи (без пересчета даты)
  - Отмена завершения задачи
  - Перепланирование уведомлений после завершения
- Тесты пересчета дат:
  - Пересчет при наступлении нового дня
  - Пересчет только один раз в день
  - Пересчет не выполняется, если новый день не наступил
  - Корректность пересчета для всех типов задач
- Тесты уведомлений:
  - Уведомления срабатывают в офлайне
  - Уведомления планируются для будущих дат
  - Уведомления не планируются для завершенных задач
  - Перепланирование уведомлений после пересчета дат

**5. Тесты на бэкенде:**
- `tests/test_task_service.py`:
  - Тест новых правил фильтрации `one_time` в `get_tasks_for_today()`:
    - Видна если `reminder_time` сегодня или просрочена (независимо от `completed`/`active`)
    - Видна если `completed=true` (даже если в будущем)
  - Тест обработки событий за предыдущий день на сервере
  - Тест единого алгоритма синхронизации на сервере
  - Тест пересчета после применения событий за предыдущий день

**6. Тесты производительности:**
- Пересчет дат не блокирует UI (асинхронное выполнение)
- Кэш обновляется эффективно
- Синхронизация очереди не блокирует UI
- Загрузка задач из кэша выполняется быстро

**7. Тесты граничных случаев:**
- Пустой кэш при первом запуске
- Очень большое количество задач в кэше
- События с некорректными `timestamp`
- Пересчет при изменении `day_start_hour`
- Пересчет при переходе через полночь
- События с одинаковыми `timestamp`

**Критерии готовности:**
- Все unit-тесты проходят
- Все интеграционные тесты проходят
- Все тесты сложных сценариев синхронизации проходят
- Все функциональные тесты проходят
- Тесты на бэкенде проходят
- Производительность приемлемая (пересчет не блокирует UI)
- Нет регрессий в онлайн-режиме
- Покрытие тестами новых функций > 80%

---

## Канонические правила фильтрации задач

Этот раздел является **единственным источником истины** для правил видимости задач на вкладках «Сегодня» и «Все задачи».  
Все реализации на бэкенде, в офлайне и в тестах должны ссылаться на него и не дублировать правила в свободной форме.

### Базовые параметры

Для определения видимости учитываются следующие параметры:
- тип задачи: `one_time`, `recurring`, `interval`;
- флаги: `completed ∈ {true,false}`, `active ∈ {true,false}`;
- положение `reminder_time` относительно текущего логического дня:
  - `PAST` — время строго раньше начала текущего логического дня;
  - `TODAY` — внутри текущего логического дня;
  - `FUTURE` — строго после конца текущего логического дня;
- целевая вкладка: «Сегодня», «Все задачи».

### Вкладка «Сегодня»

- `one_time`:
  - Видна, если `reminder_time ∈ {PAST, TODAY}` — **независимо** от `completed` и `active`.
  - Видна, если `completed = true` — **даже если** `reminder_time = FUTURE`.
- `recurring` / `interval`:
  - Если `completed = false` — видна, если `reminder_time ∈ {PAST, TODAY}`.
  - Если `completed = true` — видна, если `reminder_time ∈ {PAST, TODAY}` (задача завершена в текущем или прошлом интервале текущего логического дня).

### Вкладка «Все задачи»

- Отображаются все задачи, за исключением:
  - явно удалённых задач;
  - других случаев, определённых отдельно бизнес‑логикой (если появятся в будущем).
- Для любых дополнительных фильтров (по пользователю, статусу и т.п.) требуется отдельная спецификация и тесты, при этом базовые правила видимости выше остаются неизменными.

### Синхронизация правил

- Правила в этом разделе должны быть **идентичны** на бэкенде и в клиентской части.
- При изменении правил необходимо:
  - обновлять этот раздел как канонический;
  - синхронно вносить изменения в реализацию бэкенда и офлайна;
  - обновлять соответствующие тесты на клиенте и сервере, проверяющие соответствие реализаций таблице правил.

## Дополнительные замечания

### Настройки
- `day_start_hour` должен быть доступен в офлайне (из настроек пользователя или по умолчанию)
- Возможно, нужно сохранять `day_start_hour` в `OfflineRepository` при синхронизации

### Синхронизация
- **Критически важно:** Сервер является приоритетным источником данных
- Клиент отправляет очередь событий на сервер, сервер применяет их
- Единый алгоритм синхронизации (см. Этап 3, подэтап 3.1):
  1. Перед пересчетом: синхронизировать очередь операций, загрузить актуальное состояние с сервера
  2. После пересчета: обновить задачи в локальном кэше (для отображения)
  3. Синхронизировать очередь: отправить все операции на сервер с временными метками `timestamp` (отсортированные)
  4. Сервер обрабатывает события единым алгоритмом:
     - Сортирует все события по `timestamp` в хронологическом порядке
     - Обрабатывает события последовательно
     - При переходе от событий предыдущего дня к событиям нового дня выполняет пересчет
     - Применяет события до и после пересчета в зависимости от их `timestamp`
     - Сервер сам выполняет пересчет задач при новом дне (не зависит от клиента)
  5. Загрузить финальное состояние с сервера в клиент (включая пересчитанные даты)
- Алгоритм корректно обрабатывает любые комбинации событий и дней
- Учитывать, что сервер тоже пересчитывает даты при новом дне
- Конфликты разрешаются сервером при применении операций из очереди в хронологическом порядке
- В офлайне пересчет выполняется локально, операции остаются в очереди для синхронизации
- События с клиента должны содержать корректные временные метки для правильной хронологической обработки

### Производительность
- Пересчет дат должен быть быстрым (не блокировать UI)
- Использовать корутины для асинхронных операций
- Кэшировать результаты пересчета где возможно

### Обратная совместимость
- Старые версии приложения должны продолжать работать
- Миграция данных не требуется (логика только на клиенте)

---

## Важные замечания по правилам фильтрации

### Правила для `one_time` задач (обновлено):
1. **Видна если `reminder_time` сегодня или просрочена** - без дополнительных условий (независимо от `completed` или `active`)
2. **Видна если `completed=true`** - даже если `reminder_time` в будущем

Это означает, что завершенная `one_time` задача с датой в будущем все равно будет видна во вкладке "Сегодня".

### Правила для `recurring/interval` задач (без изменений):
- Если `completed=true` → видна если `reminder_time` сегодня или просрочена (завершена сегодня)
- Если `completed=false` → видна если `reminder_time` сегодня или просрочена

### Синхронизация правил:
- Правила должны быть **идентичными** на бэкенде и в оффлайне
- При изменении правил обновлять оба места одновременно
- Тесты должны проверять соответствие правил

### Пересчет `reminder_time` (критически важно):
- Пересчет выполняется **только один раз в день** при наступлении нового дня
- Пересчет происходит при первой загрузке задач после наступления нового дня
- Пересчет НЕ выполняется:
  - При каждом обращении к задачам
  - При завершении задачи (`completeTask`)
  - При обновлении задачи
- Логика полностью идентична бэкенду: проверка `_is_new_day()`, пересчет всех завершенных повторяющихся задач
- Для `one_time` задач пересчет НЕ выполняется никогда

---

## Порядок выполнения

Рекомендуемый порядок:
1. Этап 1 (обновление правил фильтрации) - базовая функциональность, **начинаем с бэкенда**
2. Этап 2 (пересчет дат) - основа для остального
3. Этап 3 (интеграция пересчета) - автоматизация
4. Этап 4 (пересчет после завершения) - улучшение UX
5. Этап 5 (уведомления) - завершение функциональности
6. Этап 6 (тестирование) - проверка и исправления

Каждый этап можно тестировать независимо перед переходом к следующему.

