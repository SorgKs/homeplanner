## ЛОГИКА ЛОГИЧЕСКОГО ДНЯ И `last_update`

### 1. Пустой кэш

- Если кэш задач (`tasks_cache`) **пустой**, то при вызове `updateRecurringTasksForNewDay`:
  - **вообще не проверяем** `last_update` и не используем `TaskDateCalculator.isNewDay`;
  - пересчитывать нечего, поэтому никакой "новый день" для задач не наступает;
  - метод может выполнять только инициализационные действия (при необходимости), но не должен менять даты задач.

Практический вывод:

- Проверка на пустой кэш должна выполняться **раньше**, чем логика "нового дня" (`isNewDay`).

### 2. Источник `last_update`

- Значение `last_update` не должно придумывать клиент:
  - при получении данных от сервера (полный список задач, синхронизация состояния) клиент **получает `last_update` от сервера**;
  - клиент лишь сохраняет это значение (например, через `setLastUpdateTimestamp`), но не вычисляет его сам.
- После первого успешного получения задач с сервера:
  - у клиента всегда есть валидный `last_update`;
  - дальнейшая логика `isNewDay` и `updateRecurringTasksForNewDay` опирается именно на это значение.

### 3. Поведение `updateRecurringTasksForNewDay`

- При непустом кэше:
  - метод использует `last_update` и текущий `day_start_hour`, чтобы решить, наступил ли новый логический день (`TaskDateCalculator.isNewDay`);
  - если новый день наступил, выполняется пересчёт только завершённых задач согласно правилам:
    - `one_time` — становятся неактивными, `reminderTime` не меняется;
    - `recurring`/`interval` — получают новую дату `reminderTime`, `completed` сбрасывается.
- При пустом кэше:
  - не проверяем `isNewDay`, не меняем даты задач (их нет);
  - при необходимости можем лишь обновить локально сохранённый `last_update`, полученный ранее от сервера.


