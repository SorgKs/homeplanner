## SYNC_ALGORITHM

Формальное описание алгоритма синхронизации состояния задач между клиентом и сервером.

### 1. Общие принципы

- **Сервер — приоритетный источник данных**:
  - Финальное состояние задач после синхронизации определяется сервером.
  - Клиент рассматривает своё состояние как кэш + очередь событий.
- Клиент отправляет на сервер только события (`create`, `update`, `delete`, `complete`, `uncomplete`).
- Операции пересчёта по новому дню **не отправляются** на сервер отдельно — сервер сам пересчитывает задачи.

### 2. Очередь операций на клиенте

- Каждая операция в очереди содержит:
  - идентификатор задачи;
  - тип операции (`create` / `update` / `delete` / `complete` / `uncomplete`);
  - полезную нагрузку (изменённые поля);
  - `timestamp` — время выполнения операции на клиенте.
- Требования к `timestamp`:
  - должен отражать **реальное время выполнения операции**, а не время добавления в очередь;
  - операции при отправке на сервер сортируются по `timestamp` в хронологическом порядке.

### 3. Алгоритм синхронизации на клиенте

1. При наличии сети:
   - отправить все ожидающие операции на сервер, отсортированные по `timestamp`;
   - дождаться ответа сервера с обновлённым состоянием задач;
   - сохранить полученное состояние в кэш через `OfflineRepository`.
2. При отсутствии сети:
   - операции продолжают накапливаться в очереди;
   - отображение задач и пересчёт по новому дню выполняются только локально.

### 4. Обработка очереди на сервере

1. При получении пачки операций от клиента:
   - объединить их с существующими событиями (если есть) и отсортировать все операции по `timestamp`;
   - определить `day_start_hour` из настроек пользователя;
   - инициализировать `lastProcessedDay` датой первого события.
2. Для каждой операции в хронологическом порядке:
   - вычислить логический день события по `timestamp` и `day_start_hour`;
   - если логический день операции отличается от `lastProcessedDay` и это переход на новый день:
     - выполнить пересчёт задач для нового дня (по тем же правилам, что и на клиенте);
     - обновить `last_update`;
     - обновить `lastProcessedDay`.
   - применить операцию к соответствующей задаче.
3. После обработки всех операций:
   - если текущее время относится к новому логическому дню относительно последнего события,
     но пересчёт ещё не выполнялся — выполнить пересчёт и обновить `last_update`.
4. Вернуть клиенту актуальное состояние задач.

### 5. Сопоставление с локальным пересчётом

- Клиент может выполнять пересчёт задач по новому дню в офлайне.
- После синхронизации клиент сравнивает состояние задач, полученное от сервера, с результатом
  своего локального пересчёта (см. инварианты в `OFFLINE_REQUIREMENTS.md`):
  - если различия объясняются только серверным пересчётом нового дня — состояние считается «ожидаемым»;
  - если есть отличия, не объяснимые пересчётом (изменился текст, параметры повторения и т.п.),
    задача помечается как изменённая (`changed = true`).

### 6. Конфликты и флаг `changed`

- Флаг `changed = true` на клиенте означает, что состояние задачи изменилось по итогам синхронизации
  **не только** из‑за локальных действий пользователя и **не только** из‑за пересчёта нового дня.
- Основания для установки `changed = true`:
  - события от других устройств/клиентов;
  - серверная бизнес‑логика, модифицирующая задачу сверх пересчёта.
- Не являются основанием для `changed`:
  - любые изменения, возникающие только из‑за пересчёта по новому логическому дню.
- UI должен позволять пользователю увидеть задачи с `changed = true` и явным действием
  «принять изменения», после чего флаг сбрасывается.

{
  "cells": [],
  "metadata": {
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}