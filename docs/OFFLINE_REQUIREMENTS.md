## OFFLINE_REQUIREMENTS

Высокоуровневые продуктовые и функциональные требования к офлайн‑режиму HomePlanner.

### 1. Цели

- **Основной режим работы — офлайн**:
  - Приложение должно корректно работать при отсутствии сети.
  - Все ключевые сценарии (просмотр задач, подтверждение, уведомления) должны быть доступны в офлайне.
- **Единое поведение онлайн/офлайн**:
  - При наличии сети данные синхронизируются с сервером, но UX и правила отображения задач не меняются.
  - Сервер остаётся приоритетным источником данных, клиент работает как кэш + очередь событий.

### 2. Отображение задач

#### 2.1. Вкладка «Сегодня»

- Должны корректно отображаться задачи, относящиеся к текущему логическому дню (с учётом `day_start_hour`).
- Конкретные правила видимости для разных типов задач описаны в разделе
  **«Канонические правила фильтрации задач»** ниже и являются единственным источником истины
  для реализации на бэкенде и в клиенте.

#### 2.2. Вкладка «Все задачи»

- Должны корректно отображаться все задачи с учётом их актуальных свойств
  (`enabled`, `completed`, `reminder_time` и т.д.).
- Базовые правила видимости также определены каноническим разделом фильтрации.

### 3. Уведомления

- В офлайне должны корректно срабатывать локальные уведомления при достижении времени `reminder_time`.
- Повторяющиеся и интервальные задачи должны получать корректно пересчитанные будущие `reminder_time`,
  чтобы уведомления продолжали работать без связи с сервером.
- Завершённые задачи не должны порождать новые уведомления.

### 4. Подтверждение задач (complete/uncomplete)

- В офлайне должны корректно устанавливаться и сниматься подтверждения задач (`completed`).
- Для `one_time` задач:
  - При пересчёте нового дня завершённая задача должна становиться неактивной (`enabled = false`),
    при этом `reminder_time` не меняется.
- Для `recurring` / `interval` задач:
  - При новом логическом дне выполняется пересчёт следующей даты и сброс `completed = false`
    (задача «переезжает» на следующую итерацию).

### 5. Логический день и пересчёт раз в день

Определения ниже должны одинаково использоваться на клиенте и на сервере.

#### 5.1. Определение логического дня

- Логический день — интервал длительностью 24 часа от одного значения `day_start_hour` до следующего.
- Для любого локального времени `t` функция `logical_day(t, day_start_hour)`:
  - вычисляет `start = getDayStart(t, day_start_hour)`,
  - определяет логический день как \[start, start + 24h),
  - возвращает дату `logical_day_date`, в которой лежит большая часть этого интервала.
- Функции `getDayStart` и `isNewDay` определяются так:
  - `prevStart = getDayStart(last_update, day_start_hour)`;
  - `currStart = getDayStart(now, day_start_hour)`;
  - `isNewDay = (currStart != prevStart)`.

#### 5.2. Пропущенные дни

- Предполагается, что в дни, когда приложение не запускалось, пользовательских событий нет.
- При первом запуске после паузы:
  - вычисляются `prevLD = logical_day(last_update, day_start_hour)` и
    `currLD = logical_day(now, day_start_hour)`;
  - если `currLD != prevLD`, выполняется **однократный пересчёт**,
    сразу приводящий состояние задач к виду на начало текущего логического дня;
  - не моделируется последовательный пересчёт по каждому пропущенному дню.

#### 5.3. Изменение `day_start_hour`

- Вместе с `last_update` хранится `last_day_start_hour`, по которому он вычислялся.
- При загрузке задач:
  - `oldLD = logical_day(last_update, last_day_start_hour)`;
  - `newLD = logical_day(now, current_day_start_hour)`;
  - если `newLD.date > oldLD.date`, считается, что наступил новый логический день → выполняется пересчёт;
  - после пересчёта:
    - `last_update = now`;
    - `last_day_start_hour = current_day_start_hour`.
- Изменение `day_start_hour` «назад», не сдвигающее дату логического дня вперёд, не вызывает пересчёт.

#### 5.4. Источник времени

- Все вычисления (`logical_day`, `getDayStart`, `isNewDay`, сравнение `reminder_time` с «сегодня/прошлым/будущим»)
  выполняются на основе **локального времени устройства** и текущего локального часового пояса ОС.
- При смене часового пояса или ручном изменении времени:
  - дополнительные коррекции не выполняются;
  - возможные единичные аномалии (лишний или пропущенный пересчёт) считаются допустимыми.

#### 5.5. Инварианты после пересчёта

После успешного пересчёта при наступлении нового логического дня должны выполняться инварианты:

- Общие:
  - `last_update` согласован с текущим логическим днём (по актуальному `day_start_hour`).
  - Не остаётся задач `recurring`/`interval` с `completed = true` и `reminder_time` раньше начала
    текущего логического дня.
- `one_time`:
  - Если `completed = true` и `reminder_time` находился в прошлом логическом дне или ранее —
    устанавливается `enabled = false`, `reminder_time` не изменяется.
  - Пересчёт **никогда** не изменяет `reminder_time` для `one_time` задач.
- `recurring`:
  - Для всех задач с `type = recurring` и `completed = true` до пересчёта:
    - после пересчёта `completed = false`;
    - `reminder_time` указывает на следующее по правилам повторения вхождение относительно текущего
      логического дня и не меньше начала текущего логического дня.
- `interval`:
  - Для задач с `type = interval` и `completed = true` до пересчёта:
    - после пересчёта `completed = false`;
    - `reminder_time = today_start + interval_days` (с сохранением времени или по логике бэкенда)
      и строго больше начала текущего логического дня.

### 6. Канонические правила фильтрации задач

Этот раздел является каноническим источником истины для правил фильтрации задач и используется всеми реализациями.

#### 6.1. Базовые параметры

Для определения видимости учитываются:

- тип задачи: `one_time`, `recurring`, `interval`;
- флаги: `completed ∈ {true,false}`, `enabled ∈ {true,false}`;
- положение `reminder_time` относительно текущего логического дня:
  - `PAST` — время строго раньше начала текущего логического дня;
  - `TODAY` — внутри текущего логического дня;
  - `FUTURE` — строго после конца текущего логического дня;
- целевая вкладка: «Сегодня», «Все задачи».

#### 6.2. Вкладка «Сегодня»

- Задача видна, если `enabled = true` AND (`completed = true` OR `reminder_time ∈ {PAST, TODAY}`).

#### 6.3. Вкладка «Все задачи»

- Отображаются все задачи, за исключением:
  - явно удалённых задач;
  - других случаев, определённых отдельно бизнес‑логикой.

### 7. Поведение при переходах офлайн/онлайн

- При уходе в офлайн:
  - Все изменения пользователя (create/update/delete/complete/uncomplete) попадают в очередь событий.
  - Отображение задач и уведомления продолжают работать на основе локального кэша и логики пересчёта.
- При появлении сети:
  - Очередь событий синхронизируется с сервером.
  - Клиент загружает актуальное состояние задач с сервера и обновляет локальный кэш.
  - Сервер является приоритетным источником, но клиент не навязывает результаты локального пересчёта —
    сервер тоже пересчитывает задачи по тем же правилам логического дня.


