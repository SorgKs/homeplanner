# Архитектура Offline-First в Android приложении HomePlanner

> **Примечание:** Данный документ описывает архитектуру **Android APK приложения** (клиентская часть), а не всего проекта HomePlanner. Для общей архитектуры проекта см. [ARCHITECTURE_vNext.md](ARCHITECTURE_vNext.md).

> **Статус архитектуры:** ✅ **Реализована**  
> **Миграция:** Завершена (документ в архиве: [archive/MIGRATION_TO_LOCAL_API.md](archive/MIGRATION_TO_LOCAL_API.md))  
> **Последнее обновление:** 2025-12-28

## Обзор

Android приложение HomePlanner использует **offline-first** подход, который обеспечивает:
- Мгновенную работу приложения даже без интернета
- Автоматическую синхронизацию данных при появлении соединения
- Сохранение всех пользовательских действий в локальном хранилище
- Оптимистичные обновления UI для лучшего UX

## Принципы

1. **Сервер — источник истины для всех данных**
   - Сервер является единственным источником истины для всех данных
   - Все конфликты разрешаются только на сервере
   - Клиент всегда синхронизирует локальный кэш с данными сервера после синхронизации
   - Сервер сам решает, какие операции применить, а какие пропустить при конфликтах

2. **Локальное хранилище — источник правды для UI**
   - Все данные для отображения загружаются из локального кэша
   - UI никогда не ждёт ответа сервера для отображения данных

3. **Оптимистичные обновления**
   - Пользовательские действия применяются локально немедленно
   - Изменения отправляются на сервер в фоне
   - После синхронизации локальный кэш обновляется актуальными данными с сервера

4. **Фоновая синхронизация**
   - Синхронизация с сервером происходит асинхронно, не блокируя UI
   - Очередь операций гарантирует доставку всех изменений на сервер
   - После синхронизации клиент получает актуальное состояние всех данных с сервера

5. **Разделение ответственности**
   - Чёткое разделение между работой с локальным хранилищем и сервером
   - Отдельные компоненты для чтения, записи и синхронизации

## Архитектура компонентов Android приложения

### 1. TasksApi — Прямые запросы к серверу

**Назначение:** Выполнение HTTP-запросов к REST API сервера.

**Расположение:** `android/app/src/main/java/com/homeplanner/api/TasksApi.kt`

**Ответственность:**
- Выполнение GET/POST/PUT/DELETE запросов к серверу
- Парсинг JSON-ответов
- Обработка HTTP-ошибок
- Передача cookies для выбранного пользователя

**Методы:**
```kotlin
fun getTasks(activeOnly: Boolean = true): List<Task>
fun createTask(task: Task, assignedUserIds: List<Int> = emptyList()): Task
fun updateTask(taskId: Int, task: Task, assignedUserIds: List<Int> = emptyList()): Task
fun completeTask(taskId: Int): Task
fun uncompleteTask(taskId: Int): Task
fun deleteTask(taskId: Int)
fun syncQueue(queueItems: List<SyncQueueItem>): List<Task>
```

**Особенности:**
- Не содержит логики кэширования
- Не зависит от наличия интернета (выбрасывает исключения при отсутствии)
- Используется только `SyncService` для синхронизации

---

### 2. LocalApi — Работа с локальным хранилищем для UI

**Назначение:** Предоставление данных из локального хранилища для UI с автоматическим добавлением операций в очередь синхронизации.

**Расположение:** `android/app/src/main/java/com/homeplanner/api/LocalApi.kt` ✅

**Ответственность:**
- Загрузка данных из локального кэша (Room database)
- Сохранение изменений в локальный кэш
- Добавление операций в очередь синхронизации
- Оптимистичные обновления для мгновенного отклика UI

**Методы:**
```kotlin
suspend fun getTasks(activeOnly: Boolean = true): List<Task>
suspend fun createTask(task: Task, assignedUserIds: List<Int> = emptyList()): Task
suspend fun updateTask(taskId: Int, task: Task, assignedUserIds: List<Int> = emptyList()): Task
suspend fun completeTask(taskId: Int): Task
suspend fun uncompleteTask(taskId: Int): Task
suspend fun deleteTask(taskId: Int)
```

**Особенности:**
- Все методы работают только с локальным хранилищем
- Не выполняет запросы к серверу
- Все изменения автоматически добавляются в очередь синхронизации
- Возвращает данные немедленно (оптимистичные обновления)

**Пример использования:**
```kotlin
// UI вызывает LocalApi для создания задачи
val newTask = localApi.createTask(task)
// Задача сразу появляется в UI, операция добавлена в очередь
// SyncService синхронизирует её с сервером в фоне
```

---

### 3. SyncService — Синхронизация локального хранилища с сервером

**Назначение:** Синхронизация данных между локальным хранилищем и сервером.

**Расположение:** `android/app/src/main/java/com/homeplanner/sync/SyncService.kt`

**Ответственность:**
- Синхронизация очереди операций с сервером
- Загрузка актуальных данных с сервера и сохранение в кэш
- Обработка конфликтов
- Проверка наличия интернет-соединения

**Методы:**
```kotlin
fun isOnline(): Boolean
suspend fun syncStateBeforeRecalculation(): Boolean
suspend fun syncQueue(): Result<SyncResult>
suspend fun syncCacheWithServer(
    groupsApi: GroupsApi? = null,
    usersApi: UsersApi? = null
): Result<SyncCacheResult>
```

**Алгоритм синхронизации очереди (`syncQueue()`):**
1. Проверка наличия интернет-соединения
2. Получение операций из очереди (`OfflineRepository.getPendingQueueItems()`)
3. Отправка операций на сервер через `TasksApi.syncQueue()`
4. Очистка очереди при успешной синхронизации
5. Обновление кэша данными с сервера

**Алгоритм синхронизации кэша (`syncCacheWithServer()`):**
1. Проверка наличия интернет-соединения
2. Запрос данных с сервера через `TasksApi.getTasks()`
   - Если запрос не удался → возврат ошибки (не тратим ресурсы на вычисление хеша кэша)
3. Загрузка данных из кэша для сравнения
4. Вычисление хеша кэшированных данных
5. Вычисление хеша данных с сервера
6. Сравнение хешей:
   - Если совпадают → синхронизация очереди операций, возврат `false`
   - Если различаются → сохранение данных с сервера в кэш, синхронизация очереди, возврат `true`
7. Опционально: загрузка групп и пользователей с сервера (если переданы `GroupsApi` и `UsersApi`)
8. Возврат результата с флагом обновления кэша и опциональными данными

**Оптимизация:** Сначала запрашиваем данные с сервера, и только если запрос успешен, вычисляем хеш кэша. Это позволяет избежать лишних вычислений при ошибках сети.

**Структура результата:**
```kotlin
data class SyncCacheResult(
    val cacheUpdated: Boolean,
    val users: List<UserSummary>? = null,
    val groups: Map<Int, String>? = null
)
```

**Особенности:**
- Использует `TasksApi` для запросов к серверу
- Работает только при наличии интернета
- Обрабатывает ошибки и конфликты
- Возвращает результат синхронизации
- Может синхронизировать метаданные (группы, пользователи) опционально

---

### 4. OfflineRepository — Управление локальным хранилищем

**Назначение:** Низкоуровневая работа с Room database и очередью синхронизации.

**Расположение:** `android/app/src/main/java/com/homeplanner/repository/OfflineRepository.kt`

**Ответственность:**
- Сохранение/загрузка задач в/из Room database
- Управление очередью синхронизации (SyncQueue)
- Очистка старых данных
- Управление метаданными хранилища

**Основные методы:**
```kotlin
suspend fun saveTasksToCache(tasks: List<Task>): Result<Unit>
suspend fun loadTasksFromCache(): List<Task>
suspend fun getTaskFromCache(id: Int): Task?
suspend fun deleteTaskFromCache(id: Int)
suspend fun addToSyncQueue(action: String, entityType: String, entityId: Int?, entity: Task?)
suspend fun getPendingQueueItems(): List<SyncQueueItem>
suspend fun clearAllQueue()
suspend fun updateRecurringTasksForNewDay(dayStartHour: Int): Boolean
```

---

### 5. TaskDateCalculator — Работа с логическим днём и пересчёт дат задач

**Назначение:** Реализация логики пересчёта дат задач для всех типов повторений с учётом логического дня.

**Расположение:** `android/app/src/main/java/com/homeplanner/utils/TaskDateCalculator.kt`

**Ответственность:**
- Вычисление начала логического дня с учётом `day_start_hour`
- Проверка наступления нового логического дня
- Пересчёт `reminderTime` для recurring и interval задач
- Реализация логики `_calculate_next_due_date` с бэкенда

**Основные методы:**
```kotlin
fun getDayStart(time: LocalDateTime, dayStartHour: Int): LocalDateTime
fun isNewDay(
    lastUpdateMillis: Long?,
    nowMillis: Long,
    lastDayStartHour: Int?,
    currentDayStartHour: Int
): Boolean
fun calculateNextReminderTime(
    task: Task,
    nowMillis: Long,
    dayStartHour: Int
): String
```

**Особенности:**
- Логика согласована с серверным `TaskService`
- Поддерживает типы повторений: DAILY, WEEKLY, MONTHLY, YEARLY
- Поддерживает interval задачи
- Для `one_time` задач дата не пересчитывается
- Используется `OfflineRepository.updateRecurringTasksForNewDay()` для пересчёта задач при новом дне

**Связь с требованиями:**
- Реализует функции `getDayStart` и `isNewDay` из [OFFLINE_REQUIREMENTS.md](OFFLINE_REQUIREMENTS.md) (раздел 5.1)
- Обеспечивает корректный пересчёт `reminder_time` для уведомлений (раздел 3)

---

### 6. TodayTaskFilter — Фильтрация задач для вкладки «Сегодня»

**Назначение:** Локальная фильтрация задач для отображения на вкладке «Сегодня» с учётом логического дня.

**Расположение:** `android/app/src/main/java/com/homeplanner/utils/TodayTaskFilter.kt`

**Ответственность:**
- Фильтрация задач по правилам видимости для вкладки «Сегодня»
- Учёт логического дня с учётом `day_start_hour`
- Фильтрация по выбранному пользователю (если задан)
- Применение канонических правил фильтрации задач

**Основные методы:**
```kotlin
fun filterTodayTasks(
    tasks: List<Task>,
    selectedUser: SelectedUser?,
    dayStartHour: Int
): List<Task>
```

**Правила фильтрации:**
- **one_time задачи:**
  - Видны, если `reminder_time` сегодня или в прошлом (независимо от `completed`/`active`)
  - Видны, если `completed = true`, даже если `reminder_time` в будущем
- **recurring / interval задачи:**
  - Видны, если `reminder_time` сегодня или в прошлом (`completed` не влияет)

**Особенности:**
- Логика строго следует «Каноническим правилам фильтрации задач» из [OFFLINE_REQUIREMENTS.md](OFFLINE_REQUIREMENTS.md)
- Использует `TaskDateCalculator.getDayStart()` для определения начала логического дня
- Работает только с локальными данными из кэша
- Не зависит от наличия интернета

**Связь с требованиями:**
- Реализует требования к вкладке «Сегодня» из [OFFLINE_REQUIREMENTS.md](OFFLINE_REQUIREMENTS.md) (раздел 2.1)

---

### 7. ReminderScheduler — Планирование локальных уведомлений

**Назначение:** Планирование и отмена локальных уведомлений для задач на основе их `reminder_time`.

**Расположение:** `android/app/src/main/java/com/homeplanner/ReminderScheduler.kt`

**Ответственность:**
- Планирование уведомлений через `AlarmManager`
- Отмена уведомлений для задач
- Работа с уже пересчитанными данными из кэша
- Обработка задач с `reminder_time` в прошлом (пересчёт через `TaskDateCalculator`)

**Основные методы:**
```kotlin
fun scheduleForTasks(tasks: List<Task>)
fun scheduleForTaskIfUpcoming(task: Task)
fun cancelForTask(task: Task)
fun cancelAll(tasks: List<Task>)
```

**Особенности:**
- Планирует уведомления только для активных и незавершённых задач (`active = true`, `completed = false`)
- Если `reminder_time` в прошлом для recurring/interval задач, использует `TaskDateCalculator` для пересчёта следующего времени
- Работает только с данными из кэша, не выполняет запросы к серверу
- Уведомления работают в офлайне независимо от сервера

**Связь с требованиями:**
- Реализует требования к уведомлениям из [OFFLINE_REQUIREMENTS.md](OFFLINE_REQUIREMENTS.md) (раздел 3)
- Обеспечивает корректную работу уведомлений в офлайне
- Завершённые задачи не порождают новые уведомления

---

## Поток данных

### Загрузка задач для UI

```
UI → LocalApi.getTasks()
     ↓
OfflineRepository.loadTasksFromCache()
     ↓
Room Database
     ↓
UI отображает данные (мгновенно)

[В фоне, если есть интернет]
SyncService.syncCacheWithServer()
     ↓
TasksApi.getTasks() → Server
     ↓
OfflineRepository.saveTasksToCache()
     ↓
UI обновляется при изменениях
```

### Создание задачи

```
UI → LocalApi.createTask(task)
     ↓
OfflineRepository.saveTasksToCache([task])  // Оптимистичное обновление
     ↓
OfflineRepository.addToSyncQueue("create", "task", null, task)
     ↓
UI отображает новую задачу (мгновенно)

[В фоне, если есть интернет]
SyncService.syncQueue()
     ↓
TasksApi.syncQueue([queueItem])
     ↓
Server сохраняет задачу
     ↓
OfflineRepository.saveTasksToCache([serverTask])  // Обновление с сервера
     ↓
OfflineRepository.clearAllQueue()
```

### Обновление задачи

```
UI → LocalApi.updateTask(id, task)
     ↓
OfflineRepository.saveTasksToCache([task])  // Оптимистичное обновление
     ↓
OfflineRepository.addToSyncQueue("update", "task", id, task)
     ↓
UI отображает обновлённую задачу (мгновенно)

[В фоне, если есть интернет]
SyncService.syncQueue()
     ↓
TasksApi.syncQueue([queueItem])
     ↓
Server обновляет задачу
     ↓
OfflineRepository.saveTasksToCache([serverTask])  // Обновление с сервера
     ↓
OfflineRepository.clearAllQueue()
```

## Синхронизация кэша с сервером

В `MainActivity` реализованы две отдельные функции для управления синхронизацией:

### 1. `syncCacheWithServer()` — Обёртка над SyncService для синхронизации кэша

**Назначение:** Обёртка над `SyncService.syncCacheWithServer()` для удобства работы с UI.

**Реализация:**
```kotlin
suspend fun syncCacheWithServer(tasksApi: TasksApi): Pair<Boolean, List<UserSummary>> {
    if (networkConfig == null || apiBaseUrl == null || !syncService.isOnline()) {
        return Pair(false, emptyList())
    }
    
    val groupsApi = GroupsApi(baseUrl = apiBaseUrl)
    val usersApi = UsersApi(baseUrl = apiBaseUrl)
    
    val result = syncService.syncCacheWithServer(groupsApi, usersApi)
    
    return if (result.isSuccess) {
        val syncResult = result.getOrNull()
        if (syncResult?.groups != null) {
            saveGroupsToCache(context, syncResult.groups)
        }
        Pair(syncResult?.cacheUpdated ?: false, syncResult?.users ?: emptyList())
    } else {
        Pair(false, emptyList())
    }
}
```

**Примечание:** Основная логика синхронизации находится в `SyncService.syncCacheWithServer()`, которая сначала запрашивает данные с сервера, и только при успешном ответе вычисляет хеш кэша для сравнения. Это оптимизирует использование ресурсов при ошибках сети.

**Возвращает:** `Pair<Boolean, List<UserSummary>>`
- `Boolean` — были ли изменения в кэше (требуется обновление UI)
- `List<UserSummary>` — обновлённый список пользователей

**Примечание:** Основная логика синхронизации находится в `SyncService.syncCacheWithServer()`. Этот метод является обёрткой для удобства работы с UI и загрузки метаданных (группы, пользователи).

### 2. `updateUIFromCache()` — Обновление UI из кэша

**Назначение:** Проверка синхронности UI с кэшем и обновление при расхождениях.

**Алгоритм:**
1. Загрузка данных из кэша
2. Загрузка групп из кэша
3. Вычисление хеша текущих данных UI
4. Вычисление хеша данных из кэша
5. Сравнение хешей и групп:
   - Если совпадают → возврат `false` (обновление не требуется)
   - Если различаются → объединение данных с сохранением более свежих данных (по времени обновления)
6. Обновление `allTasks` и `groups` в UI

**Особенности:**
- Сохраняет оптимистичные обновления (задачи с более новым временем обновления или отличающимся `completed`)
- Добавляет задачи, которых нет в кэше (локальные изменения, ещё не сохранённые)
- Обновляет группы только при изменениях
- **Важно:** Обновление UI происходит только если изменения затрагивают отображаемые параметры задач на текущей вкладке
- Если изменения не влияют на текущий вид (задача не видна или параметры не изменились), UI не обновляется

**Возвращает:** `Boolean` — был ли обновлён UI

## Очередь синхронизации

Все операции изменения данных (create, update, complete, uncomplete, delete) автоматически добавляются в очередь синхронизации через `OfflineRepository.addToSyncQueue()`.

**Структура очереди:**
- `action` — тип операции ("create", "update", "complete", "uncomplete", "delete")
- `entityType` — тип сущности ("task")
- `entityId` — ID сущности (если есть)
- `entity` — JSON-представление сущности (содержит время обновления для обработки конфликтов)

**Синхронизация очереди:**
- Выполняется при наличии интернета (только синхронизация, без обновления UI)
- Выполняется при успешной загрузке данных с сервера
- Выполняется при ручной синхронизации
- Операции отправляются батчами через `TasksApi.syncQueue()`
- **Важно:** Синхронизация не обновляет UI напрямую — UI обновляется только по триггерам

Детали периодической синхронизации см. в [CACHE_STRATEGY_UPDATE_V1.md](CACHE_STRATEGY_UPDATE_V1.md)

## Обработка конфликтов

**Сервер — источник истины. Конфликты обрабатываются ТОЛЬКО на сервере:**

- Сервер проверяет время обновления задачи (`updated_at`) при обработке операций из очереди синхронизации
- Если серверная версия задачи новее, чем timestamp операции клиента → операция пропускается
- Сервер сам решает, какие операции применить, а какие пропустить
- После обработки всех операций сервер возвращает актуальное состояние всех задач
- Клиент получает актуальные данные с сервера и обновляет локальный кэш
- **Важно:** Клиент не обрабатывает конфликты самостоятельно — он просто получает актуальное состояние с сервера
- Очередь синхронизации очищается после успешной синхронизации, независимо от того, были ли конфликты

## Обработка ошибок синхронизации

### Текущее состояние

**Ограничения текущей реализации:**
- Простая обработка ошибок: логирование и возврат `Result.failure`
- Отсутствие retry-логики с экспоненциальной задержкой
- Нет классификации типов ошибок
- Отсутствие уведомлений пользователя о критических ошибках

### Типы ошибок синхронизации

1. **Сетевые ошибки:**
   - Отсутствие интернет-соединения
   - Таймауты запросов
   - Прерывание соединения во время передачи

2. **Конфликты:**
   - Конфликты обрабатываются только на сервере при синхронизации очереди операций
   - Если серверная версия задачи новее (по `updated_at`), чем timestamp операции → операция пропускается
   - Сервер возвращает актуальное состояние всех задач после обработки операций
   - Клиент не получает HTTP 409 — он просто получает актуальные данные с сервера
   - **Важно:** Сервер — источник истины, клиент всегда синхронизирует локальный кэш с данными сервера

3. **Серверные ошибки:**
   - HTTP 500 (Internal Server Error)
   - HTTP 503 (Service Unavailable)
   - HTTP 429 (Too Many Requests)

4. **Ошибки валидации (HTTP 400):**
   - Некорректные данные в запросе
   - Нарушение бизнес-правил

5. **Ошибки авторизации (HTTP 401, 403):**
   - Истёкшая сессия
   - Недостаточно прав

### Стратегии обработки ошибок

#### 1. Сетевые ошибки

**Стратегия:**
- Операции остаются в очереди синхронизации
- Автоматическая повторная попытка при восстановлении соединения
- Retry с экспоненциальной задержкой (1s, 2s, 4s, 8s, 16s, max 60s)
- Максимальное количество попыток: 5

**Реализация:**
```kotlin
suspend fun syncQueueWithRetry(): Result<SyncResult> {
    var attempt = 0
    var delayMs = 1000L
    
    while (attempt < MAX_RETRY_ATTEMPTS) {
        val result = syncQueue()
        if (result.isSuccess) return result
        
        // Проверяем, является ли ошибка сетевой
        if (isNetworkError(result.exceptionOrNull())) {
            attempt++
            if (attempt < MAX_RETRY_ATTEMPTS) {
                delay(delayMs)
                delayMs = minOf(delayMs * 2, 60_000L) // Экспоненциальная задержка, max 60s
            }
        } else {
            // Не сетевые ошибки не требуют retry
            return result
        }
    }
    
    return result
}
```

#### 2. Конфликты

**Стратегия:**
- **Важно:** Конфликты обрабатываются ТОЛЬКО на сервере
- Сервер проверяет время обновления (`updated_at`) при обработке операций из очереди синхронизации
- Если серверная версия новее → операция пропускается, серверная версия остается актуальной
- После обработки всех операций сервер возвращает актуальное состояние всех задач
- Клиент получает актуальные данные и обновляет локальный кэш
- Очередь синхронизации очищается после успешной синхронизации
- **Важно:** Клиент не обрабатывает конфликты — он просто получает актуальное состояние с сервера

**Реализация:**
```kotlin
// Сервер обрабатывает конфликты самостоятельно и возвращает актуальное состояние
val tasks = tasksApi.syncQueue(queueItems)
// Обновляем кэш актуальными данными с сервера (сервер сам решил, какие операции применить)
repository.saveTasksToCache(tasks)
repository.clearAllQueue()
```

#### 3. Серверные ошибки (HTTP 500, 503)

**Стратегия:**
- Операции остаются в очереди
- Retry с увеличенной задержкой (30s, 60s, 120s)
- Максимальное количество попыток: 3
- Индикация через иконку в строке статуса (без отдельного уведомления)

#### 4. Ошибки валидации (HTTP 400)

**Стратегия:**
- Удаление операции из очереди (не имеет смысла повторять)
- Логирование ошибки с деталями
- Уведомление пользователя о некорректных данных
- Возможность исправления данных пользователем

#### 5. Ошибки авторизации (HTTP 401, 403)

**Стратегия:**
- Прекращение синхронизации
- Запрос повторной авторизации
- Уведомление пользователя о необходимости входа

### Улучшения для реализации

#### 1. Классификация ошибок

Создать enum для типов ошибок:
```kotlin
enum class SyncErrorType {
    NETWORK_ERROR,
    SERVER_ERROR,
    VALIDATION_ERROR,
    AUTH_ERROR,
    UNKNOWN_ERROR
}

data class SyncError(
    val type: SyncErrorType,
    val message: String,
    val httpCode: Int? = null,
    val retryable: Boolean = true,
    val maxRetries: Int = 5
)
```

#### 2. Retry-механизм

Реализовать retry с экспоненциальной задержкой:
- Начальная задержка: 1 секунда
- Максимальная задержка: 60 секунд
- Множитель: 2x
- Максимальное количество попыток: зависит от типа ошибки

#### 3. Уведомления пользователя

- **Важно:** При критических ошибках отдельные уведомления (Toast/Snackbar) не показываются
- Только иконка в строке статуса для индикации проблем синхронизации
- Индикатор статуса синхронизации (онлайн/оффлайн)

#### 4. Логирование и мониторинг

**Цель:** Отслеживание состояния синхронизации, диагностика проблем и анализ производительности.

##### 4.1. Детальное логирование

**Что логировать:**

1. **Операции синхронизации:**
   - Начало и завершение синхронизации очереди
   - Количество операций в очереди
   - Успешные и неудачные попытки синхронизации
   - Время выполнения синхронизации

2. **Ошибки с контекстом:**
   - Тип ошибки (сетевая, серверная, валидация, авторизация, конфликт)
   - HTTP-код (если применимо)
   - Сообщение об ошибке
   - ID задачи/операции, которая вызвала ошибку
   - Время возникновения ошибки
   - Количество попыток retry

3. **Состояние системы:**
   - Наличие интернет-соединения
   - Размер очереди синхронизации
   - Время последней успешной синхронизации
   - Количество задач в кэше

4. **Пользовательские действия:**
   - Создание/обновление/удаление задач
   - Добавление операций в очередь
   - Ручная синхронизация

**Формат логирования:**

> **Подробная информация о формате логирования:** См. [LOGGING_FORMAT.md](LOGGING_FORMAT.md)

- **Бинарный формат:** Все логи сохраняются в бинарном виде для экономии места и быстрого доступа
- **Словарь сообщений:** Использование кодов вместо текстовых описаний (текстовые описания не загружаются в приложение)
- **Структурированное хранение:** Метаданные (timestamp, уровень, тег, код сообщения, контекст)
- **Инциденты:** Отдельное сохранение инцидентов с ошибками (кроме ошибок соединения)
- **Отправка на сервер:** Автоматическая отправка аварийных логов при появлении соединения
- **Политика удаления:** Обычные логи через 7 дней, аварийные через 20 дней

##### 4.2. Отслеживание типов ошибок для анализа

**Классификация ошибок:**

1. **По типу:**
   - Сетевые ошибки (нет интернета, таймауты)
   - Серверные ошибки (500, 503, 429)
   - Ошибки валидации (400)
   - Ошибки авторизации (401, 403)
   - Конфликты (409)
   - Неизвестные ошибки

2. **По частоте:**
   - Единичные ошибки
   - Повторяющиеся ошибки
   - Массовые ошибки (много операций подряд)

3. **По критичности:**
   - Некритичные (временные сетевые проблемы)
   - Важные (серверные ошибки)
   - Критические (ошибки авторизации, массовые сбои)

**Анализ ошибок:**

```kotlin
data class ErrorStatistics(
    val errorType: SyncErrorType,
    val count: Int,
    val lastOccurrence: Long,
    val averageRetryCount: Double,
    val affectedTasks: Set<Int>
)
```

**Использование для диагностики:**
- Выявление проблемных паттернов (например, частые ошибки 500)
- Определение необходимости оптимизации (большое количество retry)
- Мониторинг состояния сервера (рост ошибок 503)
- Выявление проблем с авторизацией (ошибки 401/403)

##### 4.3. Хранение логов и инцидентов

> **Подробная информация о формате логирования:** См. [LOGGING_FORMAT.md](LOGGING_FORMAT.md)

**Краткое описание:**

- **Бинарное хранение:** Все логи в бинарном формате для экономии места
- **Инциденты:** Отдельное сохранение инцидентов с ошибками (кроме ошибок соединения)
- **Отправка на сервер:** Автоматическая отправка аварийных логов при появлении соединения
- **Политика удаления:** Обычные логи через 7 дней, аварийные через 20 дней

##### 4.4. Рекомендации по реализации

**Минимальный набор для начала:**

1. Логирование всех ошибок с типом и контекстом

**Расширенный набор:**

1. Статистика по типам ошибок
2. Анализ паттернов ошибок

**Инструменты:**

- Android Logcat для разработки
- Бинарное хранение логов в файловой системе
- Room database для хранения инцидентов
- Protocol Buffers/FlatBuffers для сериализации логов

## WebSocket для real-time обновлений

Приложение подписывается на WebSocket для получения обновлений в реальном времени:

**События:**
- `created` — новая задача создана
- `updated` — задача обновлена
- `completed` — задача выполнена
- `uncompleted` — выполнение задачи отменено
- `shown` — задача отмечена как просмотренная
- `deleted` — задача удалена

**Обработка событий:**
1. Получение события из WebSocket
2. Парсинг данных задачи
3. Проверка времени обновления:
   - Если время обновления новее текущей → обновление задачи в `allTasks`
   - Если время обновления равно, но `completed`/`active` отличается → обновление (оптимистичное обновление было применено)
   - Если время обновления старше → игнорирование (локальные данные новее)
4. Проверка влияния на текущий вид:
   - Если изменения затрагивают отображаемые параметры задач на текущей вкладке → обновление UI через рекомпозицию Compose
   - Если изменения не влияют на текущий вид (задача не видна или параметры не изменились) → UI не обновляется

## Оптимистичные обновления

Все пользовательские действия применяются локально немедленно:

1. **Создание задачи:**
   - Задача сохраняется в кэш с временным ID
   - Добавляется в очередь синхронизации
   - UI отображает задачу сразу

2. **Обновление задачи:**
   - Задача обновляется в кэше
   - Добавляется в очередь синхронизации
   - UI отображает обновлённую задачу сразу

3. **Выполнение/отмена выполнения:**
   - Статус `completed` обновляется в кэше
   - Добавляется в очередь синхронизации
   - UI обновляет чекбокс сразу

4. **Удаление задачи:**
   - Задача удаляется из кэша
   - Добавляется в очередь синхронизации
   - UI удаляет задачу из списка сразу

## Проверка синхронности

Для проверки синхронности данных используется хеширование:

```kotlin
fun calculateTasksHash(tasks: List<Task>): String {
    val digest = MessageDigest.getInstance("SHA-256")
    val sortedTasks = tasks.sortedBy { it.id }
    val data = sortedTasks.joinToString("|") { task ->
        "${task.id}:${task.updatedAt}:${task.title}:${task.reminderTime}:${task.completed}:${task.active}"
    }
    val hashBytes = digest.digest(data.toByteArray(Charsets.UTF_8))
    return hashBytes.joinToString("") { "%02x".format(it) }
}
```

**Использование:**
- Сравнение локального кэша с данными сервера
- Сравнение UI состояния с кэшем
- Определение необходимости обновления UI

## Периодические процессы

В `MainActivity` настроены периодические процессы, которые **не обновляют UI напрямую**:

1. **Проверка соединения (каждые 5 секунд):**
   - Обновление метаданных хранилища
   - Проверка статуса соединения
   - Диагностические запросы при необходимости
   - **Не обновляет UI**

2. **Синхронизация очереди:**
   - Проверка наличия операций в очереди
   - Синхронизация при наличии интернета
   - Обновление статуса соединения
   - **Не обновляет UI напрямую** — UI обновляется только при явных триггерах

## Триггеры обновления UI

UI обновляется **только по триггерам (событиям)**, а не периодически:

1. **Загрузка задач:**
   - При переключении вкладок
   - При старте приложения

2. **Пользовательские действия:**
   - Создание задачи → `LocalApi.createTask()` → обновление кэша → триггер обновления UI
   - Обновление задачи → `LocalApi.updateTask()` → обновление кэша → триггер обновления UI
   - Выполнение/отмена задачи → `LocalApi.completeTask()`/`uncompleteTask()` → обновление кэша → триггер обновления UI
   - Удаление задачи → `LocalApi.deleteTask()` → обновление кэша → триггер обновления UI

3. **WebSocket события:**
   - Получение событий `created`, `updated`, `completed`, `uncompleted`, `shown`, `deleted`
   - Обновление `allTasks` при получении события
   - **Важно:** UI обновляется только если новые данные меняют отображаемые параметры задач на текущем виде (вкладке)
   - Если изменения не влияют на текущий вид (например, задача не видна на текущей вкладке или параметры не изменились), UI не обновляется

4. **Успешная синхронизация:**
   - После успешной синхронизации кэша с сервером (`syncCacheWithServer()`)
   - Явный вызов `updateUIFromCache()` при изменениях в кэше
   - **Важно:** UI обновляется только если новые данные меняют отображаемые параметры задач на текущем виде (вкладке)
   - Если изменения не влияют на текущий вид (например, задача не видна на текущей вкладке или параметры не изменились), UI не обновляется

5. **Изменение состояния:**
   - Изменение выбранного пользователя
   - Изменение выбранной вкладки
   - Изменение фильтров

**Важно:** Периодические процессы (проверка соединения, синхронизация очереди) выполняются в фоне и **не вызывают автоматическое обновление UI**. UI обновляется только при явных триггерах, что предотвращает ненужные перерисовки и улучшает производительность.

## Обработка нового дня

При наступлении нового логического дня (по `dayStartHour`, обычно 4:00):

1. Локальный пересчёт рекуррентных задач через `OfflineRepository.updateRecurringTasksForNewDay()`
2. Если есть интернет → полная синхронизация состояния с сервером через `SyncService.syncStateBeforeRecalculation()`
3. Обновление UI из обновлённого кэша

## Миграция с TasksApiOffline на LocalApi

> **Статус:** ✅ **Завершена** (2025-01-27)  
> **Подробный план миграции:** См. [archive/MIGRATION_TO_LOCAL_API.md](archive/MIGRATION_TO_LOCAL_API.md)  
> **Результат:** `TasksApiOffline` успешно заменён на `LocalApi` + `SyncService`, файл удалён

## Преимущества новой архитектуры

1. **Чёткое разделение ответственности:**
   - `LocalApi` — для UI, только локальное хранилище
   - `TasksApi` — для сервера, только HTTP-запросы
   - `SyncService` — для синхронизации, только координация

2. **Упрощение тестирования:**
   - Каждый компонент можно тестировать изолированно
   - Легко мокировать зависимости

3. **Улучшение читаемости:**
   - Понятно, где происходит работа с кэшем, а где с сервером
   - Нет смешивания логики

4. **Гибкость:**
   - Легко изменить стратегию синхронизации
   - Легко добавить новые источники данных

## Примеры использования

### Загрузка задач в UI

```kotlin
// В MainActivity
suspend fun loadTasks() {
    // 1. Обновляем UI из кэша (мгновенно)
    val uiUpdated = updateUIFromCache()
    
    // 2. Синхронизируем кэш с сервером в фоне
    if (networkConfig != null && apiBaseUrl != null && syncService.isOnline()) {
        scope.launch(Dispatchers.IO) {
            val groupsApi = GroupsApi(baseUrl = apiBaseUrl)
            val usersApi = UsersApi(baseUrl = apiBaseUrl)
            val syncResult = syncService.syncCacheWithServer(groupsApi, usersApi)
            
            if (syncResult.isSuccess) {
                val result = syncResult.getOrNull()
                withContext(Dispatchers.Main) {
                    if (result?.users != null && result.users.isNotEmpty()) {
                        users = result.users
                    }
                    if (result?.groups != null) {
                        saveGroupsToCache(context, result.groups)
                    }
                }
                if (result?.cacheUpdated == true) {
                    // Кэш был обновлён — обновляем UI только если изменения влияют на текущий вид
                    updateUIFromCache()
                }
            }
        }
    }
}
```

### Создание задачи

```kotlin
// В MainActivity
fun createTask() {
    scope.launch(Dispatchers.IO) {
        val newTask = localApi.createTask(task, assignedUserIds)
        // Задача уже в кэше и очереди синхронизации
        // UI обновляется автоматически через updateUIFromCache()
    }
}
```

### Синхронизация очереди

```kotlin
// В MainActivity (периодическая синхронизация очереди)
// ВАЖНО: Этот процесс НЕ обновляет UI автоматически
LaunchedEffect(syncService, offlineRepository, connectionStatus) {
    while (true) {
        delay(30_000L) // Периодическая синхронизация (детали см. CACHE_STRATEGY_UPDATE_V1.md)
        
        if (connectionStatus == ConnectionStatus.ONLINE && pendingOperations > 0) {
            val syncResult = syncService.syncQueue()
            if (syncResult.isSuccess) {
                markSuccessfulRequest()
                // UI НЕ обновляется здесь автоматически
                // Обновление UI происходит только по триггерам (см. раздел "Триггеры обновления UI")
            }
        }
    }
}
```

**Примечание:** Если после синхронизации очереди требуется обновить UI (например, при получении обновлённых данных с сервера), это должно быть сделано явно через триггер, например:
- WebSocket событие обновит UI автоматически
- Явный вызов `updateUIFromCache()` при необходимости

## Заключение

Архитектура offline-first в Android приложении HomePlanner обеспечивает:
- Мгновенную работу приложения без интернета
- Автоматическую синхронизацию при появлении соединения
- Сохранение всех пользовательских действий
- Оптимистичные обновления для лучшего UX
- Чёткое разделение ответственности между компонентами

Разделение на `LocalApi`, `TasksApi` и `SyncService` делает архитектуру более понятной, тестируемой и поддерживаемой.
